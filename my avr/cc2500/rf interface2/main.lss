
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  000005ae  00000642  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000043  008000a8  008000a8  0000068a  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  0000068a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000180  00000000  00000000  000006ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000006ea  00000000  00000000  0000084a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000287  00000000  00000000  00000f34  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000b4f  00000000  00000000  000011bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000160  00000000  00000000  00001d0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001ac  00000000  00000000  00001e6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001a4  00000000  00000000  00002018  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  000021bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 6a 02 	jmp	0x4d4	; 0x4d4 <__vector_18>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee ea       	ldi	r30, 0xAE	; 174
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a8 3a       	cpi	r26, 0xA8	; 168
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a8 ea       	ldi	r26, 0xA8	; 168
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ab 3e       	cpi	r26, 0xEB	; 235
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 84 00 	call	0x108	; 0x108 <main>
  8a:	0c 94 d5 02 	jmp	0x5aa	; 0x5aa <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <uart_init>:



void uart_init(unsigned int baud)
{
 UBRRH=UART_BAUD_SELECT>>8;
  92:	9c 01       	movw	r18, r24
  94:	40 e0       	ldi	r20, 0x00	; 0
  96:	50 e0       	ldi	r21, 0x00	; 0
  98:	64 e0       	ldi	r22, 0x04	; 4
  9a:	22 0f       	add	r18, r18
  9c:	33 1f       	adc	r19, r19
  9e:	44 1f       	adc	r20, r20
  a0:	55 1f       	adc	r21, r21
  a2:	6a 95       	dec	r22
  a4:	d1 f7       	brne	.-12     	; 0x9a <uart_init+0x8>
  a6:	60 e0       	ldi	r22, 0x00	; 0
  a8:	74 e2       	ldi	r23, 0x24	; 36
  aa:	84 ef       	ldi	r24, 0xF4	; 244
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	0e 94 b3 02 	call	0x566	; 0x566 <__udivmodsi4>
  b2:	c9 01       	movw	r24, r18
  b4:	da 01       	movw	r26, r20
  b6:	01 97       	sbiw	r24, 0x01	; 1
  b8:	a1 09       	sbc	r26, r1
  ba:	b1 09       	sbc	r27, r1
  bc:	29 2f       	mov	r18, r25
  be:	3a 2f       	mov	r19, r26
  c0:	4b 2f       	mov	r20, r27
  c2:	55 27       	eor	r21, r21
  c4:	01 96       	adiw	r24, 0x01	; 1
  c6:	a1 1d       	adc	r26, r1
  c8:	b1 1d       	adc	r27, r1
  ca:	20 bd       	out	0x20, r18	; 32
 UBRRL=(uint8_t)UART_BAUD_SELECT;
  cc:	81 50       	subi	r24, 0x01	; 1
  ce:	89 b9       	out	0x09, r24	; 9
 
 UCSRB=_BV(RXEN)|_BV(TXEN);
  d0:	88 e1       	ldi	r24, 0x18	; 24
  d2:	8a b9       	out	0x0a, r24	; 10
 UCSRC=_BV(URSEL)|_BV(UCSZ1)|_BV(UCSZ0);
  d4:	86 e8       	ldi	r24, 0x86	; 134
  d6:	80 bd       	out	0x20, r24	; 32
 
}
  d8:	08 95       	ret

000000da <uart_tx_char>:



void uart_tx_char(uint8_t s)
{
 loop_until_bit_is_set(UCSRA,UDRE);
  da:	5d 9b       	sbis	0x0b, 5	; 11
  dc:	fe cf       	rjmp	.-4      	; 0xda <uart_tx_char>
 UDR=s;
  de:	8c b9       	out	0x0c, r24	; 12
}
  e0:	08 95       	ret

000000e2 <uart_rx_char>:



unsigned char uart_rx_char(void)
{
 loop_until_bit_is_set(UCSRA,RXC);
  e2:	5f 9b       	sbis	0x0b, 7	; 11
  e4:	fe cf       	rjmp	.-4      	; 0xe2 <uart_rx_char>
 if(UCSRA&(_BV(PE)|_BV(DOR)|_BV(FE)))
  e6:	8b b1       	in	r24, 0x0b	; 11
  e8:	8c 71       	andi	r24, 0x1C	; 28
  ea:	11 f0       	breq	.+4      	; 0xf0 <uart_rx_char+0xe>
  ec:	8f ef       	ldi	r24, 0xFF	; 255
  ee:	08 95       	ret
 return(unsigned char)-1;
 
 return UDR;
  f0:	8c b1       	in	r24, 0x0c	; 12
}
  f2:	08 95       	ret

000000f4 <uart_puts>:



void uart_puts(uint8_t *s )
{
  f4:	fc 01       	movw	r30, r24
  f6:	04 c0       	rjmp	.+8      	; 0x100 <uart_puts+0xc>



void uart_tx_char(uint8_t s)
{
 loop_until_bit_is_set(UCSRA,UDRE);
  f8:	5d 9b       	sbis	0x0b, 5	; 11
  fa:	fe cf       	rjmp	.-4      	; 0xf8 <uart_puts+0x4>


void uart_puts(uint8_t *s )
{
    while (*s) 
    uart_tx_char(*s++);
  fc:	31 96       	adiw	r30, 0x01	; 1


void uart_tx_char(uint8_t s)
{
 loop_until_bit_is_set(UCSRA,UDRE);
 UDR=s;
  fe:	8c b9       	out	0x0c, r24	; 12



void uart_puts(uint8_t *s )
{
    while (*s) 
 100:	80 81       	ld	r24, Z
 102:	88 23       	and	r24, r24
 104:	c9 f7       	brne	.-14     	; 0xf8 <uart_puts+0x4>
    uart_tx_char(*s++);

}
 106:	08 95       	ret

00000108 <main>:
#include"uart.h"
#include "cc2500.h"

int main(void)
{
rf_init();
 108:	0e 94 8e 02 	call	0x51c	; 0x51c <rf_init>
rf_transmit();
 10c:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <rf_transmit>
 110:	ff cf       	rjmp	.-2      	; 0x110 <main+0x8>

00000112 <spi_master_init>:
 Wait(1);	
}

void inline spi_master_init(void)//******************************************************************4
{
  CC2500_DDR=0xB0;				//spi pins (mosi, sck, ss) configure as output  important ss must shod be configured  even if it is not in use
 112:	80 eb       	ldi	r24, 0xB0	; 176
 114:	87 bb       	out	0x17, r24	; 23
  CC2500_PORT=0X4F;
 116:	8f e4       	ldi	r24, 0x4F	; 79
 118:	88 bb       	out	0x18, r24	; 24
  SPCR = 0x5D;				//spe=1(spi enable),DDRD=1(MSB first),mstr=1(master)
 11a:	8d e5       	ldi	r24, 0x5D	; 93
 11c:	8d b9       	out	0x0d, r24	; 13
  SPSR|=_BV(SPI2X);
 11e:	70 9a       	sbi	0x0e, 0	; 14
}
 120:	08 95       	ret

00000122 <cc_reset>:

void inline cc_reset(void)//*************************************************************************5
{
	CS_HIGH; 
 122:	c4 9a       	sbi	0x18, 4	; 24

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 124:	00 00       	nop
        asm("nop");
 126:	00 00       	nop
        asm("nop");
 128:	00 00       	nop
        asm("nop");
 12a:	00 00       	nop

void inline cc_reset(void)//*************************************************************************5
{
	CS_HIGH; 
    Wait(1); 
    CS_LOW; 
 12c:	c4 98       	cbi	0x18, 4	; 24

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 12e:	00 00       	nop
        asm("nop");
 130:	00 00       	nop
        asm("nop");
 132:	00 00       	nop
        asm("nop");
 134:	00 00       	nop
{
	CS_HIGH; 
    Wait(1); 
    CS_LOW; 
    Wait(1); 
    CS_HIGH; 
 136:	c4 9a       	sbi	0x18, 4	; 24
 138:	89 e2       	ldi	r24, 0x29	; 41

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 13a:	00 00       	nop
        asm("nop");
 13c:	00 00       	nop
        asm("nop");
 13e:	00 00       	nop
        asm("nop");
 140:	00 00       	nop
		
	} while (--timeout);
 142:	81 50       	subi	r24, 0x01	; 1
 144:	d1 f7       	brne	.-12     	; 0x13a <cc_reset+0x18>
    Wait(1); 
    CS_LOW; 
    Wait(1); 
    CS_HIGH; 
    Wait(41);
	CS_LOW;
 146:	c4 98       	cbi	0x18, 4	; 24
    while (GET_MISO_HIGH);
 148:	b6 99       	sbic	0x16, 6	; 22
 14a:	fe cf       	rjmp	.-4      	; 0x148 <cc_reset+0x26>
    SPDR = CC2500_SRES; 
 14c:	80 e3       	ldi	r24, 0x30	; 48
 14e:	8f b9       	out	0x0f, r24	; 15
    while((SPSR&0x80)==0);
 150:	77 9b       	sbis	0x0e, 7	; 14
 152:	fe cf       	rjmp	.-4      	; 0x150 <cc_reset+0x2e>
	while (GET_MISO_HIGH);
 154:	b6 99       	sbic	0x16, 6	; 22
 156:	fe cf       	rjmp	.-4      	; 0x154 <cc_reset+0x32>
    CS_HIGH; 
 158:	c4 9a       	sbi	0x18, 4	; 24
}
 15a:	08 95       	ret

0000015c <cc_readreg>:
 
}

uint8_t cc_readreg(uint8_t add)//*******************************************************************7
{
  CS_LOW;
 15c:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 15e:	b6 99       	sbic	0x16, 6	; 22
 160:	fe cf       	rjmp	.-4      	; 0x15e <cc_readreg+0x2>
  SPDR=(add|CC2500_READ_SINGLE);
 162:	80 68       	ori	r24, 0x80	; 128
 164:	8f b9       	out	0x0f, r24	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 166:	00 00       	nop
        asm("nop");
 168:	00 00       	nop
        asm("nop");
 16a:	00 00       	nop
        asm("nop");
 16c:	00 00       	nop
{
  CS_LOW;
  while(GET_MISO_HIGH);
  SPDR=(add|CC2500_READ_SINGLE);
  Wait(1);	
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
 16e:	77 9b       	sbis	0x0e, 7	; 14
 170:	fe cf       	rjmp	.-4      	; 0x16e <cc_readreg+0x12>
  SPDR=0;							//place data on spi resistor
 172:	1f b8       	out	0x0f, r1	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 174:	77 9b       	sbis	0x0e, 7	; 14
 176:	fe cf       	rjmp	.-4      	; 0x174 <cc_readreg+0x18>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 178:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 17a:	8f b1       	in	r24, 0x0f	; 15
}
 17c:	08 95       	ret

0000017e <cc_readregbust>:


void cc_readregbust(uint8_t add,uint8_t *dat,uint8_t leng)//*******************************************************************7
{
 17e:	fb 01       	movw	r30, r22
  CS_LOW;
 180:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 182:	b6 99       	sbic	0x16, 6	; 22
 184:	fe cf       	rjmp	.-4      	; 0x182 <cc_readregbust+0x4>
  SPDR=(add|CC2500_READ_BURST);
 186:	80 6c       	ori	r24, 0xC0	; 192
 188:	8f b9       	out	0x0f, r24	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 18a:	00 00       	nop
        asm("nop");
 18c:	00 00       	nop
        asm("nop");
 18e:	00 00       	nop
        asm("nop");
 190:	00 00       	nop
{
  CS_LOW;
  while(GET_MISO_HIGH);
  SPDR=(add|CC2500_READ_BURST);
  Wait(1);	
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
 192:	77 9b       	sbis	0x0e, 7	; 14
 194:	fe cf       	rjmp	.-4      	; 0x192 <cc_readregbust+0x14>
 196:	06 c0       	rjmp	.+12     	; 0x1a4 <cc_readregbust+0x26>
  
  while(leng--)
  {
  SPDR=0;							//place data on spi resistor
 198:	1f b8       	out	0x0f, r1	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 19a:	77 9b       	sbis	0x0e, 7	; 14
 19c:	fe cf       	rjmp	.-4      	; 0x19a <cc_readregbust+0x1c>
  *dat=SPDR;
 19e:	8f b1       	in	r24, 0x0f	; 15
 1a0:	81 93       	st	Z+, r24
  dat++;
 1a2:	41 50       	subi	r20, 0x01	; 1
  while(GET_MISO_HIGH);
  SPDR=(add|CC2500_READ_BURST);
  Wait(1);	
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
  
  while(leng--)
 1a4:	44 23       	and	r20, r20
 1a6:	c1 f7       	brne	.-16     	; 0x198 <cc_readregbust+0x1a>
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
  *dat=SPDR;
  dat++;
  }
  
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 1a8:	c4 9a       	sbi	0x18, 4	; 24
  
}
 1aa:	08 95       	ret

000001ac <readfifo>:
	cc_writeregbust(CC2500_TXFIFO,buf,60);
}


void inline readfifo(uint8_t *buf)
{
 1ac:	0f 93       	push	r16
 1ae:	1f 93       	push	r17
 1b0:	8c 01       	movw	r16, r24
	length=0;
 1b2:	10 92 a9 00 	sts	0x00A9, r1
	length=cc_readreg(CC2500_RXFIFO);
 1b6:	8f e3       	ldi	r24, 0x3F	; 63
 1b8:	0e 94 ae 00 	call	0x15c	; 0x15c <cc_readreg>
 1bc:	80 93 a9 00 	sts	0x00A9, r24
	cc_readregbust(CC2500_RXFIFO,buf,length);
 1c0:	40 91 a9 00 	lds	r20, 0x00A9
 1c4:	8f e3       	ldi	r24, 0x3F	; 63
 1c6:	b8 01       	movw	r22, r16
 1c8:	0e 94 bf 00 	call	0x17e	; 0x17e <cc_readregbust>
	
}
 1cc:	1f 91       	pop	r17
 1ce:	0f 91       	pop	r16
 1d0:	08 95       	ret

000001d2 <cc_writereg>:
  
}

void cc_writereg(uint8_t add,uint8_t data)//********************************************************8
{
  CS_LOW;
 1d2:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 1d4:	b6 99       	sbic	0x16, 6	; 22
 1d6:	fe cf       	rjmp	.-4      	; 0x1d4 <cc_writereg+0x2>
  SPDR=add;
 1d8:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
 1da:	77 9b       	sbis	0x0e, 7	; 14
 1dc:	fe cf       	rjmp	.-4      	; 0x1da <cc_writereg+0x8>
  SPDR=data;				//place data on spi resistor
 1de:	6f b9       	out	0x0f, r22	; 15
  while((SPSR&0x80)==0);	//wait foe the spi transmittion complit
 1e0:	77 9b       	sbis	0x0e, 7	; 14
 1e2:	fe cf       	rjmp	.-4      	; 0x1e0 <cc_writereg+0xe>
  CS_HIGH;
 1e4:	c4 9a       	sbi	0x18, 4	; 24

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 1e6:	00 00       	nop
        asm("nop");
 1e8:	00 00       	nop
        asm("nop");
 1ea:	00 00       	nop
        asm("nop");
 1ec:	00 00       	nop
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
  SPDR=data;				//place data on spi resistor
  while((SPSR&0x80)==0);	//wait foe the spi transmittion complit
  CS_HIGH;
  Wait(1);
}
 1ee:	08 95       	ret

000001f0 <cc_config>:
    CS_HIGH; 
}

void cc_config(void) //***********************************************************************6
{
 cc_writereg(CC2500_FSCTRL1,0x07);
 1f0:	8b e0       	ldi	r24, 0x0B	; 11
 1f2:	67 e0       	ldi	r22, 0x07	; 7
 1f4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FSCTRL0,0x00);
 1f8:	8c e0       	ldi	r24, 0x0C	; 12
 1fa:	60 e0       	ldi	r22, 0x00	; 0
 1fc:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FREQ2,0x5D);
 200:	8d e0       	ldi	r24, 0x0D	; 13
 202:	6d e5       	ldi	r22, 0x5D	; 93
 204:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FREQ1,0x93);
 208:	8e e0       	ldi	r24, 0x0E	; 14
 20a:	63 e9       	ldi	r22, 0x93	; 147
 20c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FREQ0,0xB1);//93
 210:	8f e0       	ldi	r24, 0x0F	; 15
 212:	61 eb       	ldi	r22, 0xB1	; 177
 214:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_MDMCFG4,0x2D);
 218:	80 e1       	ldi	r24, 0x10	; 16
 21a:	6d e2       	ldi	r22, 0x2D	; 45
 21c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_MDMCFG3,0x3B);
 220:	81 e1       	ldi	r24, 0x11	; 17
 222:	6b e3       	ldi	r22, 0x3B	; 59
 224:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_MDMCFG2,0x73);
 228:	82 e1       	ldi	r24, 0x12	; 18
 22a:	63 e7       	ldi	r22, 0x73	; 115
 22c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_MDMCFG1,0x22);
 230:	83 e1       	ldi	r24, 0x13	; 19
 232:	62 e2       	ldi	r22, 0x22	; 34
 234:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_MDMCFG0,0xF8);
 238:	84 e1       	ldi	r24, 0x14	; 20
 23a:	68 ef       	ldi	r22, 0xF8	; 248
 23c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_CHANNR,SELF_CHANNEL);//Channel No. 
 240:	8a e0       	ldi	r24, 0x0A	; 10
 242:	63 e0       	ldi	r22, 0x03	; 3
 244:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_DEVIATN,0x00);//
 248:	85 e1       	ldi	r24, 0x15	; 21
 24a:	60 e0       	ldi	r22, 0x00	; 0
 24c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_FREND1,0xB6);
 250:	81 e2       	ldi	r24, 0x21	; 33
 252:	66 eb       	ldi	r22, 0xB6	; 182
 254:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FREND0,0x10);
 258:	82 e2       	ldi	r24, 0x22	; 34
 25a:	60 e1       	ldi	r22, 0x10	; 16
 25c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_MCSM0,0x18);
 260:	88 e1       	ldi	r24, 0x18	; 24
 262:	68 e1       	ldi	r22, 0x18	; 24
 264:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FOCCFG,0x1D);
 268:	89 e1       	ldi	r24, 0x19	; 25
 26a:	6d e1       	ldi	r22, 0x1D	; 29
 26c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_BSCFG,0x1C);
 270:	8a e1       	ldi	r24, 0x1A	; 26
 272:	6c e1       	ldi	r22, 0x1C	; 28
 274:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_AGCCTRL2,0xC7);
 278:	8b e1       	ldi	r24, 0x1B	; 27
 27a:	67 ec       	ldi	r22, 0xC7	; 199
 27c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_AGCCTRL1,0x00);
 280:	8c e1       	ldi	r24, 0x1C	; 28
 282:	60 e0       	ldi	r22, 0x00	; 0
 284:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_AGCCTRL0,0xB2);//f8
 288:	8d e1       	ldi	r24, 0x1D	; 29
 28a:	62 eb       	ldi	r22, 0xB2	; 178
 28c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_FSCAL3,0xEA);
 290:	83 e2       	ldi	r24, 0x23	; 35
 292:	6a ee       	ldi	r22, 0xEA	; 234
 294:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FSCAL2,0x0A);
 298:	84 e2       	ldi	r24, 0x24	; 36
 29a:	6a e0       	ldi	r22, 0x0A	; 10
 29c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FSCAL1,0x00);
 2a0:	85 e2       	ldi	r24, 0x25	; 37
 2a2:	60 e0       	ldi	r22, 0x00	; 0
 2a4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FSCAL0,0x11);
 2a8:	86 e2       	ldi	r24, 0x26	; 38
 2aa:	61 e1       	ldi	r22, 0x11	; 17
 2ac:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_FSTEST,0x59);
 2b0:	89 e2       	ldi	r24, 0x29	; 41
 2b2:	69 e5       	ldi	r22, 0x59	; 89
 2b4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_TEST2,0x88);
 2b8:	8c e2       	ldi	r24, 0x2C	; 44
 2ba:	68 e8       	ldi	r22, 0x88	; 136
 2bc:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_TEST1,0x31);
 2c0:	8d e2       	ldi	r24, 0x2D	; 45
 2c2:	61 e3       	ldi	r22, 0x31	; 49
 2c4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_TEST0,0x0B);
 2c8:	8e e2       	ldi	r24, 0x2E	; 46
 2ca:	6b e0       	ldi	r22, 0x0B	; 11
 2cc:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_IOCFG2,0x06);  //iocfg2
 2d0:	80 e0       	ldi	r24, 0x00	; 0
 2d2:	66 e0       	ldi	r22, 0x06	; 6
 2d4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_IOCFG0,0x06);  //iocfg0
 2d8:	82 e0       	ldi	r24, 0x02	; 2
 2da:	66 e0       	ldi	r22, 0x06	; 6
 2dc:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 cc_writereg(CC2500_PKTCTRL1,0x0D); //pktctrl1
 2e0:	87 e0       	ldi	r24, 0x07	; 7
 2e2:	6d e0       	ldi	r22, 0x0D	; 13
 2e4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_PKTCTRL0,0x45);  //pktctrl 0 
 2e8:	88 e0       	ldi	r24, 0x08	; 8
 2ea:	65 e4       	ldi	r22, 0x45	; 69
 2ec:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_ADDR,SELF_ADDR);//device address
 2f0:	89 e0       	ldi	r24, 0x09	; 9
 2f2:	62 e0       	ldi	r22, 0x02	; 2
 2f4:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_PKTLEN,0xFF);
 2f8:	86 e0       	ldi	r24, 0x06	; 6
 2fa:	6f ef       	ldi	r22, 0xFF	; 255
 2fc:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 
 //sync bits
 cc_writereg(CC2500_SYNC1,0x12);
 300:	84 e0       	ldi	r24, 0x04	; 4
 302:	62 e1       	ldi	r22, 0x12	; 18
 304:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 cc_writereg(CC2500_SYNC0,0x34);
 308:	85 e0       	ldi	r24, 0x05	; 5
 30a:	64 e3       	ldi	r22, 0x34	; 52
 30c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
 310:	8a e0       	ldi	r24, 0x0A	; 10

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 312:	00 00       	nop
        asm("nop");
 314:	00 00       	nop
        asm("nop");
 316:	00 00       	nop
        asm("nop");
 318:	00 00       	nop
		
	} while (--timeout);
 31a:	81 50       	subi	r24, 0x01	; 1
 31c:	d1 f7       	brne	.-12     	; 0x312 <cc_config+0x122>
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 31e:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 320:	b6 99       	sbic	0x16, 6	; 22
 322:	fe cf       	rjmp	.-4      	; 0x320 <cc_config+0x130>
  SPDR=data;						//place data on spi resistor
 324:	8a e3       	ldi	r24, 0x3A	; 58
 326:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 328:	77 9b       	sbis	0x0e, 7	; 14
 32a:	fe cf       	rjmp	.-4      	; 0x328 <cc_config+0x138>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 32c:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 32e:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 330:	00 00       	nop
        asm("nop");
 332:	00 00       	nop
        asm("nop");
 334:	00 00       	nop
        asm("nop");
 336:	00 00       	nop
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 338:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 33a:	b6 99       	sbic	0x16, 6	; 22
 33c:	fe cf       	rjmp	.-4      	; 0x33a <cc_config+0x14a>
  SPDR=data;						//place data on spi resistor
 33e:	8b e3       	ldi	r24, 0x3B	; 59
 340:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 342:	77 9b       	sbis	0x0e, 7	; 14
 344:	fe cf       	rjmp	.-4      	; 0x342 <cc_config+0x152>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 346:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 348:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 34a:	00 00       	nop
        asm("nop");
 34c:	00 00       	nop
        asm("nop");
 34e:	00 00       	nop
        asm("nop");
 350:	00 00       	nop
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 352:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 354:	b6 99       	sbic	0x16, 6	; 22
 356:	fe cf       	rjmp	.-4      	; 0x354 <cc_config+0x164>
  SPDR=data;						//place data on spi resistor
 358:	86 e3       	ldi	r24, 0x36	; 54
 35a:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 35c:	77 9b       	sbis	0x0e, 7	; 14
 35e:	fe cf       	rjmp	.-4      	; 0x35c <cc_config+0x16c>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 360:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 362:	8f b1       	in	r24, 0x0f	; 15
 Wait(1);
 cc_strobe(CC2500_SFTX);  //flux txfifo
 Wait(1);
 cc_strobe(CC2500_SIDLE); //ideale mode
 
}
 364:	08 95       	ret

00000366 <cc_writeregbust>:
  CS_HIGH;
  Wait(1);
}

void cc_writeregbust(uint8_t addr,uint8_t* data,uint8_t lengt)
{
 366:	fb 01       	movw	r30, r22
  CS_LOW;
 368:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 36a:	b6 99       	sbic	0x16, 6	; 22
 36c:	fe cf       	rjmp	.-4      	; 0x36a <cc_writeregbust+0x4>
  SPDR=addr|CC2500_WRITE_BURST;
 36e:	80 64       	ori	r24, 0x40	; 64
 370:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
 372:	77 9b       	sbis	0x0e, 7	; 14
 374:	fe cf       	rjmp	.-4      	; 0x372 <cc_writeregbust+0xc>
 376:	06 c0       	rjmp	.+12     	; 0x384 <cc_writeregbust+0x1e>
  while(lengt--)
  {
	  SPDR=*data;				//place data on spi resistor
 378:	80 81       	ld	r24, Z
 37a:	8f b9       	out	0x0f, r24	; 15
	  while((SPSR&0x80)==0);	//wait foe the spi transmittion complit
 37c:	77 9b       	sbis	0x0e, 7	; 14
 37e:	fe cf       	rjmp	.-4      	; 0x37c <cc_writeregbust+0x16>
	  data++;
 380:	31 96       	adiw	r30, 0x01	; 1
 382:	41 50       	subi	r20, 0x01	; 1
{
  CS_LOW;
  while(GET_MISO_HIGH);
  SPDR=addr|CC2500_WRITE_BURST;
  while((SPSR&0x80)==0);			//pull the ss line to down to activate slave 
  while(lengt--)
 384:	44 23       	and	r20, r20
 386:	c1 f7       	brne	.-16     	; 0x378 <cc_writeregbust+0x12>
  {
	  SPDR=*data;				//place data on spi resistor
	  while((SPSR&0x80)==0);	//wait foe the spi transmittion complit
	  data++;
  }
  CS_HIGH;
 388:	c4 9a       	sbi	0x18, 4	; 24
  
}
 38a:	08 95       	ret

0000038c <writefifo>:
 sei();	 
}


void  writefifo(uint8_t *buf,uint8_t len)
{
 38c:	0f 93       	push	r16
 38e:	1f 93       	push	r17
 390:	8c 01       	movw	r16, r24
	cc_writereg(CC2500_TXFIFO,len);
 392:	8f e3       	ldi	r24, 0x3F	; 63
 394:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
	cc_writereg(CC2500_TXFIFO,SELF_ADDR);
 398:	8f e3       	ldi	r24, 0x3F	; 63
 39a:	62 e0       	ldi	r22, 0x02	; 2
 39c:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <cc_writereg>
	cc_writeregbust(CC2500_TXFIFO,buf,60);
 3a0:	8f e3       	ldi	r24, 0x3F	; 63
 3a2:	b8 01       	movw	r22, r16
 3a4:	4c e3       	ldi	r20, 0x3C	; 60
 3a6:	0e 94 b3 01 	call	0x366	; 0x366 <cc_writeregbust>
}
 3aa:	1f 91       	pop	r17
 3ac:	0f 91       	pop	r16
 3ae:	08 95       	ret

000003b0 <rf_transmit>:
	
}

void  rf_transmit()//**************************************************************************2
{
 cli();
 3b0:	f8 94       	cli
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 3b2:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 3b4:	b6 99       	sbic	0x16, 6	; 22
 3b6:	fe cf       	rjmp	.-4      	; 0x3b4 <rf_transmit+0x4>
  SPDR=data;						//place data on spi resistor
 3b8:	86 e3       	ldi	r24, 0x36	; 54
 3ba:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 3bc:	77 9b       	sbis	0x0e, 7	; 14
 3be:	fe cf       	rjmp	.-4      	; 0x3bc <rf_transmit+0xc>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 3c0:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 3c2:	8f b1       	in	r24, 0x0f	; 15

void  rf_transmit()//**************************************************************************2
{
 cli();
 cc_strobe(CC2500_SIDLE); //ideale mode
 writefifo(txdata,64);
 3c4:	8b e6       	ldi	r24, 0x6B	; 107
 3c6:	90 e0       	ldi	r25, 0x00	; 0
 3c8:	60 e4       	ldi	r22, 0x40	; 64
 3ca:	0e 94 c6 01 	call	0x38c	; 0x38c <writefifo>
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 3ce:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 3d0:	b6 99       	sbic	0x16, 6	; 22
 3d2:	fe cf       	rjmp	.-4      	; 0x3d0 <rf_transmit+0x20>
  SPDR=data;						//place data on spi resistor
 3d4:	85 e3       	ldi	r24, 0x35	; 53
 3d6:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 3d8:	77 9b       	sbis	0x0e, 7	; 14
 3da:	fe cf       	rjmp	.-4      	; 0x3d8 <rf_transmit+0x28>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 3dc:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 3de:	8f b1       	in	r24, 0x0f	; 15
{
 cli();
 cc_strobe(CC2500_SIDLE); //ideale mode
 writefifo(txdata,64);
 cc_strobe(CC2500_STX);	 //transmitter mode
 while(GET_GDO2_LOW);
 3e0:	b1 9b       	sbis	0x16, 1	; 22
 3e2:	fe cf       	rjmp	.-4      	; 0x3e0 <rf_transmit+0x30>
 while(GET_GDO2_HIGH);
 3e4:	b1 99       	sbic	0x16, 1	; 22
 3e6:	fe cf       	rjmp	.-4      	; 0x3e4 <rf_transmit+0x34>
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 3e8:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 3ea:	b6 99       	sbic	0x16, 6	; 22
 3ec:	fe cf       	rjmp	.-4      	; 0x3ea <rf_transmit+0x3a>
  SPDR=data;						//place data on spi resistor
 3ee:	8a e3       	ldi	r24, 0x3A	; 58
 3f0:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 3f2:	77 9b       	sbis	0x0e, 7	; 14
 3f4:	fe cf       	rjmp	.-4      	; 0x3f2 <rf_transmit+0x42>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 3f6:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 3f8:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 3fa:	00 00       	nop
        asm("nop");
 3fc:	00 00       	nop
        asm("nop");
 3fe:	00 00       	nop
        asm("nop");
 400:	00 00       	nop
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 402:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 404:	b6 99       	sbic	0x16, 6	; 22
 406:	fe cf       	rjmp	.-4      	; 0x404 <rf_transmit+0x54>
  SPDR=data;						//place data on spi resistor
 408:	8b e3       	ldi	r24, 0x3B	; 59
 40a:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 40c:	77 9b       	sbis	0x0e, 7	; 14
 40e:	fe cf       	rjmp	.-4      	; 0x40c <rf_transmit+0x5c>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 410:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 412:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 414:	00 00       	nop
        asm("nop");
 416:	00 00       	nop
        asm("nop");
 418:	00 00       	nop
        asm("nop");
 41a:	00 00       	nop
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 41c:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 41e:	b6 99       	sbic	0x16, 6	; 22
 420:	fe cf       	rjmp	.-4      	; 0x41e <rf_transmit+0x6e>
  SPDR=data;						//place data on spi resistor
 422:	86 e3       	ldi	r24, 0x36	; 54
 424:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 426:	77 9b       	sbis	0x0e, 7	; 14
 428:	fe cf       	rjmp	.-4      	; 0x426 <rf_transmit+0x76>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 42a:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 42c:	8f b1       	in	r24, 0x0f	; 15
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 42e:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 430:	b6 99       	sbic	0x16, 6	; 22
 432:	fe cf       	rjmp	.-4      	; 0x430 <rf_transmit+0x80>
  SPDR=data;						//place data on spi resistor
 434:	84 e3       	ldi	r24, 0x34	; 52
 436:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 438:	77 9b       	sbis	0x0e, 7	; 14
 43a:	fe cf       	rjmp	.-4      	; 0x438 <rf_transmit+0x88>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 43c:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 43e:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 440:	00 00       	nop
        asm("nop");
 442:	00 00       	nop
        asm("nop");
 444:	00 00       	nop
        asm("nop");
 446:	00 00       	nop
 cc_strobe(CC2500_SFTX);  //flux txfifo
 Wait(1);
 cc_strobe(CC2500_SIDLE); //ideale mode
 cc_strobe(CC2500_SRX);	//receive mode
 Wait(1); 
 sei();
 448:	78 94       	sei
}
 44a:	08 95       	ret

0000044c <cc_strobe>:
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 44c:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 44e:	b6 99       	sbic	0x16, 6	; 22
 450:	fe cf       	rjmp	.-4      	; 0x44e <cc_strobe+0x2>
  SPDR=data;						//place data on spi resistor
 452:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 454:	77 9b       	sbis	0x0e, 7	; 14
 456:	fe cf       	rjmp	.-4      	; 0x454 <cc_strobe+0x8>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 458:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 45a:	8f b1       	in	r24, 0x0f	; 15
}
 45c:	08 95       	ret

0000045e <Wait>:

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 45e:	00 00       	nop
        asm("nop");
 460:	00 00       	nop
        asm("nop");
 462:	00 00       	nop
        asm("nop");
 464:	00 00       	nop
		
	} while (--timeout);
 466:	81 50       	subi	r24, 0x01	; 1
 468:	d1 f7       	brne	.-12     	; 0x45e <Wait>
}
 46a:	08 95       	ret

0000046c <rf_receive>:
 sei();
}

void inline rf_receive() //**************************************************************************3
{
 readfifo(rxdata);
 46c:	8a ea       	ldi	r24, 0xAA	; 170
 46e:	90 e0       	ldi	r25, 0x00	; 0
 470:	0e 94 d6 00 	call	0x1ac	; 0x1ac <readfifo>
 uart_puts("receive>>>");
 474:	80 e6       	ldi	r24, 0x60	; 96
 476:	90 e0       	ldi	r25, 0x00	; 0
 478:	0e 94 7a 00 	call	0xf4	; 0xf4 <uart_puts>
 uart_puts(rxdata);
 47c:	8a ea       	ldi	r24, 0xAA	; 170
 47e:	90 e0       	ldi	r25, 0x00	; 0
 480:	0e 94 7a 00 	call	0xf4	; 0xf4 <uart_puts>
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 484:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 486:	b6 99       	sbic	0x16, 6	; 22
 488:	fe cf       	rjmp	.-4      	; 0x486 <rf_receive+0x1a>
  SPDR=data;						//place data on spi resistor
 48a:	8a e3       	ldi	r24, 0x3A	; 58
 48c:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 48e:	77 9b       	sbis	0x0e, 7	; 14
 490:	fe cf       	rjmp	.-4      	; 0x48e <rf_receive+0x22>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 492:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 494:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 496:	00 00       	nop
        asm("nop");
 498:	00 00       	nop
        asm("nop");
 49a:	00 00       	nop
        asm("nop");
 49c:	00 00       	nop
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 49e:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 4a0:	b6 99       	sbic	0x16, 6	; 22
 4a2:	fe cf       	rjmp	.-4      	; 0x4a0 <rf_receive+0x34>
  SPDR=data;						//place data on spi resistor
 4a4:	86 e3       	ldi	r24, 0x36	; 54
 4a6:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 4a8:	77 9b       	sbis	0x0e, 7	; 14
 4aa:	fe cf       	rjmp	.-4      	; 0x4a8 <rf_receive+0x3c>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 4ac:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 4ae:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 4b0:	00 00       	nop
        asm("nop");
 4b2:	00 00       	nop
        asm("nop");
 4b4:	00 00       	nop
        asm("nop");
 4b6:	00 00       	nop
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 4b8:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 4ba:	b6 99       	sbic	0x16, 6	; 22
 4bc:	fe cf       	rjmp	.-4      	; 0x4ba <rf_receive+0x4e>
  SPDR=data;						//place data on spi resistor
 4be:	84 e3       	ldi	r24, 0x34	; 52
 4c0:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 4c2:	77 9b       	sbis	0x0e, 7	; 14
 4c4:	fe cf       	rjmp	.-4      	; 0x4c2 <rf_receive+0x56>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 4c6:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 4c8:	8f b1       	in	r24, 0x0f	; 15

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 4ca:	00 00       	nop
        asm("nop");
 4cc:	00 00       	nop
        asm("nop");
 4ce:	00 00       	nop
        asm("nop");
 4d0:	00 00       	nop
 Wait(1);
 cc_strobe(CC2500_SIDLE);  //IDLE MODE
 Wait(1);
 cc_strobe(CC2500_SRX);	//receive mode
 Wait(1);	
}
 4d2:	08 95       	ret

000004d4 <__vector_18>:




ISR (INT2_vect) 
{ 
 4d4:	1f 92       	push	r1
 4d6:	0f 92       	push	r0
 4d8:	0f b6       	in	r0, 0x3f	; 63
 4da:	0f 92       	push	r0
 4dc:	11 24       	eor	r1, r1
 4de:	2f 93       	push	r18
 4e0:	3f 93       	push	r19
 4e2:	4f 93       	push	r20
 4e4:	5f 93       	push	r21
 4e6:	6f 93       	push	r22
 4e8:	7f 93       	push	r23
 4ea:	8f 93       	push	r24
 4ec:	9f 93       	push	r25
 4ee:	af 93       	push	r26
 4f0:	bf 93       	push	r27
 4f2:	ef 93       	push	r30
 4f4:	ff 93       	push	r31
      rf_receive();
 4f6:	0e 94 36 02 	call	0x46c	; 0x46c <rf_receive>
}
 4fa:	ff 91       	pop	r31
 4fc:	ef 91       	pop	r30
 4fe:	bf 91       	pop	r27
 500:	af 91       	pop	r26
 502:	9f 91       	pop	r25
 504:	8f 91       	pop	r24
 506:	7f 91       	pop	r23
 508:	6f 91       	pop	r22
 50a:	5f 91       	pop	r21
 50c:	4f 91       	pop	r20
 50e:	3f 91       	pop	r19
 510:	2f 91       	pop	r18
 512:	0f 90       	pop	r0
 514:	0f be       	out	0x3f, r0	; 63
 516:	0f 90       	pop	r0
 518:	1f 90       	pop	r1
 51a:	18 95       	reti

0000051c <rf_init>:
 Wait(1);	
}

void inline spi_master_init(void)//******************************************************************4
{
  CC2500_DDR=0xB0;				//spi pins (mosi, sck, ss) configure as output  important ss must shod be configured  even if it is not in use
 51c:	80 eb       	ldi	r24, 0xB0	; 176
 51e:	87 bb       	out	0x17, r24	; 23
  CC2500_PORT=0X4F;
 520:	8f e4       	ldi	r24, 0x4F	; 79
 522:	88 bb       	out	0x18, r24	; 24
  SPCR = 0x5D;				//spe=1(spi enable),DDRD=1(MSB first),mstr=1(master)
 524:	8d e5       	ldi	r24, 0x5D	; 93
 526:	8d b9       	out	0x0d, r24	; 13
  SPSR|=_BV(SPI2X);
 528:	70 9a       	sbi	0x0e, 0	; 14


void inline rf_init(void) 
{
 spi_master_init();
 uart_init(9600);
 52a:	80 e8       	ldi	r24, 0x80	; 128
 52c:	95 e2       	ldi	r25, 0x25	; 37
 52e:	0e 94 49 00 	call	0x92	; 0x92 <uart_init>
 cc_reset();
 532:	0e 94 91 00 	call	0x122	; 0x122 <cc_reset>
 cc_config();
 536:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <cc_config>
 53a:	84 e6       	ldi	r24, 0x64	; 100

void Wait(uint8_t timeout) //*************************************************************************10
{
	// This sequence uses exactly 8 clock cycle for each round
    do {
        asm("nop");
 53c:	00 00       	nop
        asm("nop");
 53e:	00 00       	nop
        asm("nop");
 540:	00 00       	nop
        asm("nop");
 542:	00 00       	nop
		
	} while (--timeout);
 544:	81 50       	subi	r24, 0x01	; 1
 546:	d1 f7       	brne	.-12     	; 0x53c <rf_init+0x20>
  
}

uint8_t cc_strobe(uint8_t data) //***********************************************************************9
{
  CS_LOW;								//pull the ss line to down to activate slave 
 548:	c4 98       	cbi	0x18, 4	; 24
  while(GET_MISO_HIGH);
 54a:	b6 99       	sbic	0x16, 6	; 22
 54c:	fe cf       	rjmp	.-4      	; 0x54a <rf_init+0x2e>
  SPDR=data;						//place data on spi resistor
 54e:	84 e3       	ldi	r24, 0x34	; 52
 550:	8f b9       	out	0x0f, r24	; 15
  while((SPSR&0x80)==0);			//wait foe the spi transmittion complit
 552:	77 9b       	sbis	0x0e, 7	; 14
 554:	fe cf       	rjmp	.-4      	; 0x552 <rf_init+0x36>
  CS_HIGH;								//pull the ss line to up to deactivate the slave
 556:	c4 9a       	sbi	0x18, 4	; 24
  return SPDR;
 558:	8f b1       	in	r24, 0x0f	; 15
 uart_init(9600);
 cc_reset();
 cc_config();
 Wait(100);   
 cc_strobe(CC2500_SRX); //receive mode
 MCUCSR=0x40;
 55a:	80 e4       	ldi	r24, 0x40	; 64
 55c:	84 bf       	out	0x34, r24	; 52
 GICR=0x20;
 55e:	80 e2       	ldi	r24, 0x20	; 32
 560:	8b bf       	out	0x3b, r24	; 59
 sei();	 
 562:	78 94       	sei
}
 564:	08 95       	ret

00000566 <__udivmodsi4>:
 566:	a1 e2       	ldi	r26, 0x21	; 33
 568:	1a 2e       	mov	r1, r26
 56a:	aa 1b       	sub	r26, r26
 56c:	bb 1b       	sub	r27, r27
 56e:	fd 01       	movw	r30, r26
 570:	0d c0       	rjmp	.+26     	; 0x58c <__udivmodsi4_ep>

00000572 <__udivmodsi4_loop>:
 572:	aa 1f       	adc	r26, r26
 574:	bb 1f       	adc	r27, r27
 576:	ee 1f       	adc	r30, r30
 578:	ff 1f       	adc	r31, r31
 57a:	a2 17       	cp	r26, r18
 57c:	b3 07       	cpc	r27, r19
 57e:	e4 07       	cpc	r30, r20
 580:	f5 07       	cpc	r31, r21
 582:	20 f0       	brcs	.+8      	; 0x58c <__udivmodsi4_ep>
 584:	a2 1b       	sub	r26, r18
 586:	b3 0b       	sbc	r27, r19
 588:	e4 0b       	sbc	r30, r20
 58a:	f5 0b       	sbc	r31, r21

0000058c <__udivmodsi4_ep>:
 58c:	66 1f       	adc	r22, r22
 58e:	77 1f       	adc	r23, r23
 590:	88 1f       	adc	r24, r24
 592:	99 1f       	adc	r25, r25
 594:	1a 94       	dec	r1
 596:	69 f7       	brne	.-38     	; 0x572 <__udivmodsi4_loop>
 598:	60 95       	com	r22
 59a:	70 95       	com	r23
 59c:	80 95       	com	r24
 59e:	90 95       	com	r25
 5a0:	9b 01       	movw	r18, r22
 5a2:	ac 01       	movw	r20, r24
 5a4:	bd 01       	movw	r22, r26
 5a6:	cf 01       	movw	r24, r30
 5a8:	08 95       	ret

000005aa <_exit>:
 5aa:	f8 94       	cli

000005ac <__stop_program>:
 5ac:	ff cf       	rjmp	.-2      	; 0x5ac <__stop_program>
