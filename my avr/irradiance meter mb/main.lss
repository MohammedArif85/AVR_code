
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001658  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00001658  0000170c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000247  008000a8  008000a8  00001754  2**0
                  ALLOC
  3 .eeprom       00000004  00810000  00810000  00001754  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  00001758  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000385  00000000  00000000  00001778  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001b6c  00000000  00000000  00001afd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000003dd  00000000  00000000  00003669  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001714  00000000  00000000  00003a46  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002b0  00000000  00000000  0000515c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000515  00000000  00000000  0000540c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000011bb  00000000  00000000  00005921  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00006adc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a1 01 	jmp	0x342	; 0x342 <__ctors_end>
       4:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
       8:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
       c:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      10:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      14:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      18:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      1c:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      20:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      24:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      28:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      2c:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      30:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      34:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      38:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      3c:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      40:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      44:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      48:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      4c:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>
      50:	0c 94 be 01 	jmp	0x37c	; 0x37c <__bad_interrupt>

00000054 <__c.2486>:
      54:	48 54 54 50 2f 31 2e 30 20 34 30 31 20 55 6e 61     HTTP/1.0 401 Una
      64:	75 74 68 6f 72 69 7a 65 64 0d 0a 43 6f 6e 74 65     uthorized..Conte
      74:	6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f 68 74     nt-Type: text/ht
      84:	6d 6c 0d 0a 0d 0a 3c 68 31 3e 34 30 31 20 55 6e     ml....<h1>401 Un
      94:	61 75 74 68 6f 72 69 7a 65 64 3c 2f 68 31 3e 00     authorized</h1>.

000000a4 <__c.2484>:
      a4:	3c 70 3e 55 73 61 67 65 3a 20 68 74 74 70 3a 2f     <p>Usage: http:/
      b4:	2f 68 6f 73 74 5f 6f 72 5f 69 70 2f 70 61 73 73     /host_or_ip/pass
      c4:	77 6f 72 64 3c 2f 70 3e 0a 00                       word</p>..

000000ce <__c.2482>:
      ce:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
      de:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
      ee:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00              ext/html.....

000000fb <__c.2479>:
      fb:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     10b:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     11b:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 3c 68 31 3e     ext/html....<h1>
     12b:	32 30 30 20 4f 4b 3c 2f 68 31 3e 00                 200 OK</h1>.

00000137 <__c.2447>:
     137:	3c 2f 63 65 6e 74 65 72 3e 3c 68 72 3e 3c 62 72     </center><hr><br
     147:	3e 76 65 72 73 69 6f 6e 20 31 2e 30 2c 0a 00        >version 1.0,..

00000156 <__c.2445>:
     156:	2f 31 22 3e 53 77 69 74 63 68 20 6f 6e 3c 2f 61     /1">Switch on</a
     166:	3e 3c 70 3e 00                                      ><p>.

0000016b <__c.2443>:
     16b:	2f 30 22 3e 53 77 69 74 63 68 20 6f 66 66 3c 2f     /0">Switch off</
     17b:	61 3e 3c 70 3e 00                                   a><p>.

00000181 <__c.2441>:
     181:	20 3c 73 6d 61 6c 6c 3e 3c 61 20 68 72 65 66 3d      <small><a href=
     191:	22 2e 22 3e 5b 72 65 66 72 65 73 68 20 73 74 61     ".">[refresh sta
     1a1:	74 75 73 5d 3c 2f 61 3e 3c 2f 73 6d 61 6c 6c 3e     tus]</a></small>
     1b1:	3c 2f 70 3e 0a 3c 70 3e 3c 61 20 68 72 65 66 3d     </p>.<p><a href=
     1c1:	22 2e 00                                            "..

000001c4 <__c.2439>:
     1c4:	4f 46 46 00                                         OFF.

000001c8 <__c.2437>:
     1c8:	3c 66 6f 6e 74 20 63 6f 6c 6f 72 3d 22 23 30 30     <font color="#00
     1d8:	46 46 30 30 22 3e 20 4f 4e 3c 2f 66 6f 6e 74 3e     FF00"> ON</font>
     1e8:	00                                                  .

000001e9 <__c.2435>:
     1e9:	3c 63 65 6e 74 65 72 3e 3c 70 3e 4f 75 74 70 75     <center><p>Outpu
     1f9:	74 20 69 73 3a 20 00                                t is: .

00000200 <__c.2433>:
     200:	20 4a 6f 75 6c 65 73 3c 2f 63 65 6e 74 65 72 3e      Joules</center>
     210:	3c 2f 68 32 3e 3c 2f 70 3e 00                       </h2></p>.

0000021a <__c.2431>:
     21a:	3c 63 65 6e 74 65 72 3e 3c 70 3e 3c 68 32 3e 49     <center><p><h2>I
     22a:	72 72 61 64 69 61 6e 63 65 20 69 73 3a 20 00        rradiance is: .

00000239 <__c.2429>:
     239:	3c 48 31 3e 53 6f 6c 61 72 20 49 72 72 61 64 69     <H1>Solar Irradi
     249:	61 6e 63 65 20 4d 65 74 65 72 3c 2f 48 31 3e 00     ance Meter</H1>.

00000259 <__c.2427>:
     259:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     269:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     279:	65 78 74 2f 68 74 6d 6c 0d 0a 50 72 61 67 6d 61     ext/html..Pragma
     289:	3a 20 6e 6f 2d 63 61 63 68 65 0d 0a 52 65 66 72     : no-cache..Refr
     299:	65 73 68 3a 20 32 30 0d 0a 0d 0a 00                 esh: 20.....

000002a5 <__c.2414>:
     2a5:	61 64 64 20 61 20 74 72 61 69 6c 69 6e 67 20 73     add a trailing s
     2b5:	6c 61 73 68 20 74 6f 20 74 68 65 20 75 72 6c 0a     lash to the url.
     2c5:	00                                                  .

000002c6 <__c.2412>:
     2c6:	3c 68 31 3e 33 30 31 20 4d 6f 76 65 64 20 50 65     <h1>301 Moved Pe
     2d6:	72 6d 61 6e 65 6e 74 6c 79 3c 2f 68 31 3e 0a 00     rmanently</h1>..

000002e6 <__c.2410>:
     2e6:	2f 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     /..Content-Type:
     2f6:	20 74 65 78 74 2f 68 74 6d 6c 0d 0a 50 72 61 67      text/html..Prag
     306:	6d 61 3a 20 6e 6f 2d 63 61 63 68 65 0d 0a 0d 0a     ma: no-cache....
     316:	00                                                  .

00000317 <__c.2408>:
     317:	48 54 54 50 2f 31 2e 30 20 33 30 31 20 4d 6f 76     HTTP/1.0 301 Mov
     327:	65 64 20 50 65 72 6d 61 6e 65 6e 74 6c 79 0d 0a     ed Permanently..
     337:	4c 6f 63 61 74 69 6f 6e 3a 20 00                    Location: .

00000342 <__ctors_end>:
     342:	11 24       	eor	r1, r1
     344:	1f be       	out	0x3f, r1	; 63
     346:	cf e5       	ldi	r28, 0x5F	; 95
     348:	d8 e0       	ldi	r29, 0x08	; 8
     34a:	de bf       	out	0x3e, r29	; 62
     34c:	cd bf       	out	0x3d, r28	; 61

0000034e <__do_copy_data>:
     34e:	10 e0       	ldi	r17, 0x00	; 0
     350:	a0 e6       	ldi	r26, 0x60	; 96
     352:	b0 e0       	ldi	r27, 0x00	; 0
     354:	e8 e5       	ldi	r30, 0x58	; 88
     356:	f6 e1       	ldi	r31, 0x16	; 22
     358:	02 c0       	rjmp	.+4      	; 0x35e <.do_copy_data_start>

0000035a <.do_copy_data_loop>:
     35a:	05 90       	lpm	r0, Z+
     35c:	0d 92       	st	X+, r0

0000035e <.do_copy_data_start>:
     35e:	a8 3a       	cpi	r26, 0xA8	; 168
     360:	b1 07       	cpc	r27, r17
     362:	d9 f7       	brne	.-10     	; 0x35a <.do_copy_data_loop>

00000364 <__do_clear_bss>:
     364:	12 e0       	ldi	r17, 0x02	; 2
     366:	a8 ea       	ldi	r26, 0xA8	; 168
     368:	b0 e0       	ldi	r27, 0x00	; 0
     36a:	01 c0       	rjmp	.+2      	; 0x36e <.do_clear_bss_start>

0000036c <.do_clear_bss_loop>:
     36c:	1d 92       	st	X+, r1

0000036e <.do_clear_bss_start>:
     36e:	af 3e       	cpi	r26, 0xEF	; 239
     370:	b1 07       	cpc	r27, r17
     372:	e1 f7       	brne	.-8      	; 0x36c <.do_clear_bss_loop>
     374:	0e 94 b9 08 	call	0x1172	; 0x1172 <main>
     378:	0c 94 2a 0b 	jmp	0x1654	; 0x1654 <_exit>

0000037c <__bad_interrupt>:
     37c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000380 <enc28j60ReadOp>:
//
#define waitspi() while(!(SPSR&(1<<SPIF)))

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
        CSACTIVE;
     380:	c4 98       	cbi	0x18, 4	; 24
        // issue read command
        SPDR = op | (address & ADDR_MASK);
     382:	96 2f       	mov	r25, r22
     384:	9f 71       	andi	r25, 0x1F	; 31
     386:	98 2b       	or	r25, r24
     388:	9f b9       	out	0x0f, r25	; 15
        waitspi();
     38a:	77 9b       	sbis	0x0e, 7	; 14
     38c:	fe cf       	rjmp	.-4      	; 0x38a <enc28j60ReadOp+0xa>
        // read data
        SPDR = 0x00;
     38e:	1f b8       	out	0x0f, r1	; 15
        waitspi();
     390:	77 9b       	sbis	0x0e, 7	; 14
     392:	fe cf       	rjmp	.-4      	; 0x390 <enc28j60ReadOp+0x10>
        // do dummy read if needed (for mac and mii, see datasheet page 29)
        if(address & 0x80)
     394:	67 ff       	sbrs	r22, 7
     396:	03 c0       	rjmp	.+6      	; 0x39e <enc28j60ReadOp+0x1e>
        {
                SPDR = 0x00;
     398:	1f b8       	out	0x0f, r1	; 15
                waitspi();
     39a:	77 9b       	sbis	0x0e, 7	; 14
     39c:	fe cf       	rjmp	.-4      	; 0x39a <enc28j60ReadOp+0x1a>
        }
        // release CS
        CSPASSIVE;
     39e:	c4 9a       	sbi	0x18, 4	; 24
        return(SPDR);
     3a0:	8f b1       	in	r24, 0x0f	; 15
}
     3a2:	08 95       	ret

000003a4 <enc28j60WriteOp>:

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     3a4:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     3a6:	6f 71       	andi	r22, 0x1F	; 31
     3a8:	68 2b       	or	r22, r24
     3aa:	6f b9       	out	0x0f, r22	; 15
        waitspi();
     3ac:	77 9b       	sbis	0x0e, 7	; 14
     3ae:	fe cf       	rjmp	.-4      	; 0x3ac <enc28j60WriteOp+0x8>
        // write data
        SPDR = data;
     3b0:	4f b9       	out	0x0f, r20	; 15
        waitspi();
     3b2:	77 9b       	sbis	0x0e, 7	; 14
     3b4:	fe cf       	rjmp	.-4      	; 0x3b2 <enc28j60WriteOp+0xe>
        CSPASSIVE;
     3b6:	c4 9a       	sbi	0x18, 4	; 24
}
     3b8:	08 95       	ret

000003ba <enc28j60ReadBuffer>:

void enc28j60ReadBuffer(uint16_t len, uint8_t* data)
{
     3ba:	ac 01       	movw	r20, r24
     3bc:	fb 01       	movw	r30, r22
        CSACTIVE;
     3be:	c4 98       	cbi	0x18, 4	; 24
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
     3c0:	8a e3       	ldi	r24, 0x3A	; 58
     3c2:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     3c4:	77 9b       	sbis	0x0e, 7	; 14
     3c6:	fe cf       	rjmp	.-4      	; 0x3c4 <enc28j60ReadBuffer+0xa>
     3c8:	9a 01       	movw	r18, r20
     3ca:	df 01       	movw	r26, r30
     3cc:	07 c0       	rjmp	.+14     	; 0x3dc <enc28j60ReadBuffer+0x22>
        while(len)
        {
                len--;
                // read data
                SPDR = 0x00;
     3ce:	1f b8       	out	0x0f, r1	; 15
                waitspi();
     3d0:	77 9b       	sbis	0x0e, 7	; 14
     3d2:	fe cf       	rjmp	.-4      	; 0x3d0 <enc28j60ReadBuffer+0x16>
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
        waitspi();
        while(len)
        {
                len--;
     3d4:	21 50       	subi	r18, 0x01	; 1
     3d6:	30 40       	sbci	r19, 0x00	; 0
                // read data
                SPDR = 0x00;
                waitspi();
                *data = SPDR;
     3d8:	8f b1       	in	r24, 0x0f	; 15
     3da:	8d 93       	st	X+, r24
{
        CSACTIVE;
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
        waitspi();
        while(len)
     3dc:	21 15       	cp	r18, r1
     3de:	31 05       	cpc	r19, r1
     3e0:	b1 f7       	brne	.-20     	; 0x3ce <enc28j60ReadBuffer+0x14>
                SPDR = 0x00;
                waitspi();
                *data = SPDR;
                data++;
        }
        *data='\0';
     3e2:	e4 0f       	add	r30, r20
     3e4:	f5 1f       	adc	r31, r21
     3e6:	10 82       	st	Z, r1
        CSPASSIVE;
     3e8:	c4 9a       	sbi	0x18, 4	; 24
}
     3ea:	08 95       	ret

000003ec <enc28j60WriteBuffer>:

void enc28j60WriteBuffer(uint16_t len, uint8_t* data)
{
     3ec:	9c 01       	movw	r18, r24
     3ee:	fb 01       	movw	r30, r22
        CSACTIVE;
     3f0:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
     3f2:	8a e7       	ldi	r24, 0x7A	; 122
     3f4:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     3f6:	77 9b       	sbis	0x0e, 7	; 14
     3f8:	fe cf       	rjmp	.-4      	; 0x3f6 <enc28j60WriteBuffer+0xa>
     3fa:	07 c0       	rjmp	.+14     	; 0x40a <enc28j60WriteBuffer+0x1e>
        while(len)
        {
                len--;
                // write data
                SPDR = *data;
     3fc:	80 81       	ld	r24, Z
     3fe:	8f b9       	out	0x0f, r24	; 15
                data++;
                waitspi();
     400:	77 9b       	sbis	0x0e, 7	; 14
     402:	fe cf       	rjmp	.-4      	; 0x400 <enc28j60WriteBuffer+0x14>
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
        {
                len--;
     404:	21 50       	subi	r18, 0x01	; 1
     406:	30 40       	sbci	r19, 0x00	; 0
                // write data
                SPDR = *data;
                data++;
     408:	31 96       	adiw	r30, 0x01	; 1
{
        CSACTIVE;
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
     40a:	21 15       	cp	r18, r1
     40c:	31 05       	cpc	r19, r1
     40e:	b1 f7       	brne	.-20     	; 0x3fc <enc28j60WriteBuffer+0x10>
                // write data
                SPDR = *data;
                data++;
                waitspi();
        }
        CSPASSIVE;
     410:	c4 9a       	sbi	0x18, 4	; 24
}
     412:	08 95       	ret

00000414 <enc28j60SetBank>:

void enc28j60SetBank(uint8_t address)
{
     414:	48 2f       	mov	r20, r24
        // set the bank (if needed)
        if((address & BANK_MASK) != Enc28j60Bank)
     416:	28 2f       	mov	r18, r24
     418:	30 e0       	ldi	r19, 0x00	; 0
     41a:	20 76       	andi	r18, 0x60	; 96
     41c:	30 70       	andi	r19, 0x00	; 0
     41e:	80 91 ac 00 	lds	r24, 0x00AC
     422:	90 e0       	ldi	r25, 0x00	; 0
     424:	28 17       	cp	r18, r24
     426:	39 07       	cpc	r19, r25
     428:	d9 f0       	breq	.+54     	; 0x460 <enc28j60SetBank+0x4c>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     42a:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     42c:	8f eb       	ldi	r24, 0xBF	; 191
     42e:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     430:	77 9b       	sbis	0x0e, 7	; 14
     432:	fe cf       	rjmp	.-4      	; 0x430 <enc28j60SetBank+0x1c>
        // write data
        SPDR = data;
     434:	83 e0       	ldi	r24, 0x03	; 3
     436:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     438:	77 9b       	sbis	0x0e, 7	; 14
     43a:	fe cf       	rjmp	.-4      	; 0x438 <enc28j60SetBank+0x24>
        CSPASSIVE;
     43c:	c4 9a       	sbi	0x18, 4	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     43e:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     440:	8f e9       	ldi	r24, 0x9F	; 159
     442:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     444:	77 9b       	sbis	0x0e, 7	; 14
     446:	fe cf       	rjmp	.-4      	; 0x444 <enc28j60SetBank+0x30>
        // set the bank (if needed)
        if((address & BANK_MASK) != Enc28j60Bank)
        {
                // set the bank
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
                enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
     448:	85 e0       	ldi	r24, 0x05	; 5
     44a:	35 95       	asr	r19
     44c:	27 95       	ror	r18
     44e:	8a 95       	dec	r24
     450:	e1 f7       	brne	.-8      	; 0x44a <enc28j60SetBank+0x36>
        CSACTIVE;
        // issue write command
        SPDR = op | (address & ADDR_MASK);
        waitspi();
        // write data
        SPDR = data;
     452:	2f b9       	out	0x0f, r18	; 15
        waitspi();
     454:	77 9b       	sbis	0x0e, 7	; 14
     456:	fe cf       	rjmp	.-4      	; 0x454 <enc28j60SetBank+0x40>
        CSPASSIVE;
     458:	c4 9a       	sbi	0x18, 4	; 24
        if((address & BANK_MASK) != Enc28j60Bank)
        {
                // set the bank
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
                enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
                Enc28j60Bank = (address & BANK_MASK);
     45a:	40 76       	andi	r20, 0x60	; 96
     45c:	40 93 ac 00 	sts	0x00AC, r20
     460:	08 95       	ret

00000462 <enc28j60Read>:
        }
}

uint8_t enc28j60Read(uint8_t address)
{
     462:	1f 93       	push	r17
     464:	18 2f       	mov	r17, r24
        // set the bank
        enc28j60SetBank(address);
     466:	0e 94 0a 02 	call	0x414	; 0x414 <enc28j60SetBank>
        // do the read
        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
     46a:	80 e0       	ldi	r24, 0x00	; 0
     46c:	61 2f       	mov	r22, r17
     46e:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
}
     472:	1f 91       	pop	r17
     474:	08 95       	ret

00000476 <enc28j60Write>:
	
	return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
     476:	0f 93       	push	r16
     478:	1f 93       	push	r17
     47a:	18 2f       	mov	r17, r24
     47c:	06 2f       	mov	r16, r22
        // set the bank
        enc28j60SetBank(address);
     47e:	0e 94 0a 02 	call	0x414	; 0x414 <enc28j60SetBank>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     482:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     484:	1f 71       	andi	r17, 0x1F	; 31
     486:	10 64       	ori	r17, 0x40	; 64
     488:	1f b9       	out	0x0f, r17	; 15
        waitspi();
     48a:	77 9b       	sbis	0x0e, 7	; 14
     48c:	fe cf       	rjmp	.-4      	; 0x48a <enc28j60Write+0x14>
        // write data
        SPDR = data;
     48e:	0f b9       	out	0x0f, r16	; 15
        waitspi();
     490:	77 9b       	sbis	0x0e, 7	; 14
     492:	fe cf       	rjmp	.-4      	; 0x490 <enc28j60Write+0x1a>
        CSPASSIVE;
     494:	c4 9a       	sbi	0x18, 4	; 24
{
        // set the bank
        enc28j60SetBank(address);
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}
     496:	1f 91       	pop	r17
     498:	0f 91       	pop	r16
     49a:	08 95       	ret

0000049c <enc28j60PhyReadH>:
        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
}

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
     49c:	68 2f       	mov	r22, r24

	// Set the right address and start the register read operation
	enc28j60Write(MIREGADR, address);
     49e:	84 ed       	ldi	r24, 0xD4	; 212
     4a0:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
     4a4:	82 ed       	ldi	r24, 0xD2	; 210
     4a6:	61 e0       	ldi	r22, 0x01	; 1
     4a8:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     4ac:	80 e5       	ldi	r24, 0x50	; 80
     4ae:	8a 95       	dec	r24
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <enc28j60PhyReadH+0x12>
        _delay_us(15);

	// wait until the PHY read completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
     4b2:	8a ee       	ldi	r24, 0xEA	; 234
     4b4:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
     4b8:	80 fd       	sbrc	r24, 0
     4ba:	fb cf       	rjmp	.-10     	; 0x4b2 <enc28j60PhyReadH+0x16>

	// reset reading bit
	enc28j60Write(MICMD, 0x00);
     4bc:	82 ed       	ldi	r24, 0xD2	; 210
     4be:	60 e0       	ldi	r22, 0x00	; 0
     4c0:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	
	return (enc28j60Read(MIRDH));
     4c4:	89 ed       	ldi	r24, 0xD9	; 217
     4c6:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
}
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	08 95       	ret

000004ce <enc28j60PhyWrite>:
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
     4ce:	0f 93       	push	r16
     4d0:	1f 93       	push	r17
     4d2:	98 2f       	mov	r25, r24
     4d4:	16 2f       	mov	r17, r22
     4d6:	07 2f       	mov	r16, r23
        // set the PHY register address
        enc28j60Write(MIREGADR, address);
     4d8:	84 ed       	ldi	r24, 0xD4	; 212
     4da:	69 2f       	mov	r22, r25
     4dc:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        // write the PHY data
        enc28j60Write(MIWRL, data);
     4e0:	86 ed       	ldi	r24, 0xD6	; 214
     4e2:	61 2f       	mov	r22, r17
     4e4:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        enc28j60Write(MIWRH, data>>8);
     4e8:	87 ed       	ldi	r24, 0xD7	; 215
     4ea:	60 2f       	mov	r22, r16
     4ec:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
     4f0:	10 e5       	ldi	r17, 0x50	; 80
     4f2:	03 c0       	rjmp	.+6      	; 0x4fa <enc28j60PhyWrite+0x2c>
     4f4:	81 2f       	mov	r24, r17
     4f6:	8a 95       	dec	r24
     4f8:	f1 f7       	brne	.-4      	; 0x4f6 <enc28j60PhyWrite+0x28>
        // wait until the PHY write completes
        while(enc28j60Read(MISTAT) & MISTAT_BUSY){
     4fa:	8a ee       	ldi	r24, 0xEA	; 234
     4fc:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
     500:	80 fd       	sbrc	r24, 0
     502:	f8 cf       	rjmp	.-16     	; 0x4f4 <enc28j60PhyWrite+0x26>
                _delay_us(15);
        }
}
     504:	1f 91       	pop	r17
     506:	0f 91       	pop	r16
     508:	08 95       	ret

0000050a <enc28j60clkout>:

void enc28j60clkout(uint8_t clk)
{
        //setup clkout: 2 is 12.5MHz:
	enc28j60Write(ECOCON, clk & 0x7);
     50a:	68 2f       	mov	r22, r24
     50c:	67 70       	andi	r22, 0x07	; 7
     50e:	85 e7       	ldi	r24, 0x75	; 117
     510:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
}
     514:	08 95       	ret

00000516 <enc28j60Init>:

void enc28j60Init(uint8_t* macaddr)
{
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	ec 01       	movw	r28, r24
	// initialize I/O
        // ss as output:
	ENC28J60_CONTROL_DDR |= 1<<ENC28J60_CONTROL_CS;
     51c:	bc 9a       	sbi	0x17, 4	; 23
	CSPASSIVE; // ss=0
     51e:	c4 9a       	sbi	0x18, 4	; 24
        //	
	ENC28J60_CONTROL_DDR  |= 1<<ENC28J60_CONTROL_SI | 1<<ENC28J60_CONTROL_SCK; // mosi, sck output
     520:	87 b3       	in	r24, 0x17	; 23
     522:	80 6a       	ori	r24, 0xA0	; 160
     524:	87 bb       	out	0x17, r24	; 23
	cbi(ENC28J60_CONTROL_DDR,ENC28J60_CONTROL_SO); // MISO is input
     526:	be 98       	cbi	0x17, 6	; 23
        //
        cbi(ENC28J60_CONTROL_PORT,ENC28J60_CONTROL_SI); // MOSI low
     528:	c5 98       	cbi	0x18, 5	; 24
        cbi(ENC28J60_CONTROL_PORT,ENC28J60_CONTROL_SCK); // SCK low
     52a:	c7 98       	cbi	0x18, 7	; 24
	//
	// initialize SPI interface
	// master mode and Fosc/2 clock:
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);//SPCR = (1<<SPE)|(1<<MSTR);
     52c:	81 e5       	ldi	r24, 0x51	; 81
     52e:	8d b9       	out	0x0d, r24	; 13
        SPSR |= (1<<SPI2X);
     530:	70 9a       	sbi	0x0e, 0	; 14
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     532:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     534:	8f ef       	ldi	r24, 0xFF	; 255
     536:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     538:	77 9b       	sbis	0x0e, 7	; 14
     53a:	fe cf       	rjmp	.-4      	; 0x538 <enc28j60Init+0x22>
        // write data
        SPDR = data;
     53c:	8f ef       	ldi	r24, 0xFF	; 255
     53e:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     540:	77 9b       	sbis	0x0e, 7	; 14
     542:	fe cf       	rjmp	.-4      	; 0x540 <enc28j60Init+0x2a>
        CSPASSIVE;
     544:	c4 9a       	sbi	0x18, 4	; 24
     546:	8d ec       	ldi	r24, 0xCD	; 205
     548:	8a 95       	dec	r24
     54a:	f1 f7       	brne	.-4      	; 0x548 <enc28j60Init+0x32>
	//while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	gNextPacketPtr = RXSTART_INIT;
     54c:	10 92 ae 00 	sts	0x00AE, r1
     550:	10 92 ad 00 	sts	0x00AD, r1
        // Rx start
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
     554:	88 e0       	ldi	r24, 0x08	; 8
     556:	60 e0       	ldi	r22, 0x00	; 0
     558:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
     55c:	89 e0       	ldi	r24, 0x09	; 9
     55e:	60 e0       	ldi	r22, 0x00	; 0
     560:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
     564:	8c e0       	ldi	r24, 0x0C	; 12
     566:	60 e0       	ldi	r22, 0x00	; 0
     568:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
     56c:	8d e0       	ldi	r24, 0x0D	; 13
     56e:	60 e0       	ldi	r22, 0x00	; 0
     570:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// RX end
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
     574:	8a e0       	ldi	r24, 0x0A	; 10
     576:	6e ef       	ldi	r22, 0xFE	; 254
     578:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
     57c:	8b e0       	ldi	r24, 0x0B	; 11
     57e:	69 e1       	ldi	r22, 0x19	; 25
     580:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// TX start
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
     584:	84 e0       	ldi	r24, 0x04	; 4
     586:	6f ef       	ldi	r22, 0xFF	; 255
     588:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
     58c:	85 e0       	ldi	r24, 0x05	; 5
     58e:	69 e1       	ldi	r22, 0x19	; 25
     590:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// TX end
	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
     594:	86 e0       	ldi	r24, 0x06	; 6
     596:	6f ef       	ldi	r22, 0xFF	; 255
     598:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
     59c:	87 e0       	ldi	r24, 0x07	; 7
     59e:	6f e1       	ldi	r22, 0x1F	; 31
     5a0:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        // Type     ETH.DST
        // ARP      BROADCAST
        // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
        // in binary these poitions are:11 0000 0011 1111
        // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
     5a4:	88 e3       	ldi	r24, 0x38	; 56
     5a6:	60 eb       	ldi	r22, 0xB0	; 176
     5a8:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(EPMM0, 0x3f);
     5ac:	88 e2       	ldi	r24, 0x28	; 40
     5ae:	6f e3       	ldi	r22, 0x3F	; 63
     5b0:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(EPMM1, 0x30);
     5b4:	89 e2       	ldi	r24, 0x29	; 41
     5b6:	60 e3       	ldi	r22, 0x30	; 48
     5b8:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(EPMCSL, 0xf9);
     5bc:	80 e3       	ldi	r24, 0x30	; 48
     5be:	69 ef       	ldi	r22, 0xF9	; 249
     5c0:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(EPMCSH, 0xf7);
     5c4:	81 e3       	ldi	r24, 0x31	; 49
     5c6:	67 ef       	ldi	r22, 0xF7	; 247
     5c8:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        //
        //
	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
     5cc:	80 ec       	ldi	r24, 0xC0	; 192
     5ce:	6d e0       	ldi	r22, 0x0D	; 13
     5d0:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
     5d4:	81 ec       	ldi	r24, 0xC1	; 193
     5d6:	60 e0       	ldi	r22, 0x00	; 0
     5d8:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     5dc:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     5de:	82 e8       	ldi	r24, 0x82	; 130
     5e0:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     5e2:	77 9b       	sbis	0x0e, 7	; 14
     5e4:	fe cf       	rjmp	.-4      	; 0x5e2 <enc28j60Init+0xcc>
        // write data
        SPDR = data;
     5e6:	82 e3       	ldi	r24, 0x32	; 50
     5e8:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     5ea:	77 9b       	sbis	0x0e, 7	; 14
     5ec:	fe cf       	rjmp	.-4      	; 0x5ea <enc28j60Init+0xd4>
        CSPASSIVE;
     5ee:	c4 9a       	sbi	0x18, 4	; 24
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
	// enable automatic padding to 60bytes and CRC operations
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
	// set inter-frame gap (non-back-to-back)
	enc28j60Write(MAIPGL, 0x12);
     5f0:	86 ec       	ldi	r24, 0xC6	; 198
     5f2:	62 e1       	ldi	r22, 0x12	; 18
     5f4:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
     5f8:	87 ec       	ldi	r24, 0xC7	; 199
     5fa:	6c e0       	ldi	r22, 0x0C	; 12
     5fc:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
     600:	84 ec       	ldi	r24, 0xC4	; 196
     602:	62 e1       	ldi	r22, 0x12	; 18
     604:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// Set the maximum packet size which the controller will accept
        // Do not send packets longer than MAX_FRAMELEN:
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
     608:	8a ec       	ldi	r24, 0xCA	; 202
     60a:	6c ed       	ldi	r22, 0xDC	; 220
     60c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
     610:	8b ec       	ldi	r24, 0xCB	; 203
     612:	65 e0       	ldi	r22, 0x05	; 5
     614:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// do bank 3 stuff
        // write MAC address
        // NOTE: MAC address in ENC28J60 is byte-backward
        enc28j60Write(MAADR5, macaddr[0]);
     618:	84 ee       	ldi	r24, 0xE4	; 228
     61a:	68 81       	ld	r22, Y
     61c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        enc28j60Write(MAADR4, macaddr[1]);
     620:	85 ee       	ldi	r24, 0xE5	; 229
     622:	69 81       	ldd	r22, Y+1	; 0x01
     624:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        enc28j60Write(MAADR3, macaddr[2]);
     628:	82 ee       	ldi	r24, 0xE2	; 226
     62a:	6a 81       	ldd	r22, Y+2	; 0x02
     62c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        enc28j60Write(MAADR2, macaddr[3]);
     630:	83 ee       	ldi	r24, 0xE3	; 227
     632:	6b 81       	ldd	r22, Y+3	; 0x03
     634:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        enc28j60Write(MAADR1, macaddr[4]);
     638:	80 ee       	ldi	r24, 0xE0	; 224
     63a:	6c 81       	ldd	r22, Y+4	; 0x04
     63c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        enc28j60Write(MAADR0, macaddr[5]);
     640:	81 ee       	ldi	r24, 0xE1	; 225
     642:	6d 81       	ldd	r22, Y+5	; 0x05
     644:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
     648:	80 e1       	ldi	r24, 0x10	; 16
     64a:	60 e0       	ldi	r22, 0x00	; 0
     64c:	71 e0       	ldi	r23, 0x01	; 1
     64e:	0e 94 67 02 	call	0x4ce	; 0x4ce <enc28j60PhyWrite>
	// switch to bank 0
	enc28j60SetBank(ECON1);
     652:	8f e1       	ldi	r24, 0x1F	; 31
     654:	0e 94 0a 02 	call	0x414	; 0x414 <enc28j60SetBank>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     658:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     65a:	8b e9       	ldi	r24, 0x9B	; 155
     65c:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     65e:	77 9b       	sbis	0x0e, 7	; 14
     660:	fe cf       	rjmp	.-4      	; 0x65e <enc28j60Init+0x148>
        // write data
        SPDR = data;
     662:	80 ec       	ldi	r24, 0xC0	; 192
     664:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     666:	77 9b       	sbis	0x0e, 7	; 14
     668:	fe cf       	rjmp	.-4      	; 0x666 <enc28j60Init+0x150>
        CSPASSIVE;
     66a:	c4 9a       	sbi	0x18, 4	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     66c:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     66e:	8f e9       	ldi	r24, 0x9F	; 159
     670:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     672:	77 9b       	sbis	0x0e, 7	; 14
     674:	fe cf       	rjmp	.-4      	; 0x672 <enc28j60Init+0x15c>
        // write data
        SPDR = data;
     676:	84 e0       	ldi	r24, 0x04	; 4
     678:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     67a:	77 9b       	sbis	0x0e, 7	; 14
     67c:	fe cf       	rjmp	.-4      	; 0x67a <enc28j60Init+0x164>
        CSPASSIVE;
     67e:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60SetBank(ECON1);
	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
}
     680:	df 91       	pop	r29
     682:	cf 91       	pop	r28
     684:	08 95       	ret

00000686 <enc28j60getrev>:

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
	return(enc28j60Read(EREVID));
     686:	82 e7       	ldi	r24, 0x72	; 114
     688:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
}
     68c:	08 95       	ret

0000068e <enc28j60linkup>:

// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
     68e:	81 e1       	ldi	r24, 0x11	; 17
     690:	0e 94 4e 02 	call	0x49c	; 0x49c <enc28j60PhyReadH>
     694:	20 e0       	ldi	r18, 0x00	; 0
     696:	89 2b       	or	r24, r25
     698:	09 f0       	breq	.+2      	; 0x69c <enc28j60linkup+0xe>
     69a:	21 e0       	ldi	r18, 0x01	; 1
}
     69c:	82 2f       	mov	r24, r18
     69e:	08 95       	ret

000006a0 <enc28j60PacketSend>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     6a0:	df 92       	push	r13
     6a2:	ef 92       	push	r14
     6a4:	ff 92       	push	r15
     6a6:	0f 93       	push	r16
     6a8:	1f 93       	push	r17
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
     6b0:	8b 01       	movw	r16, r22

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     6b2:	3f e9       	ldi	r19, 0x9F	; 159
     6b4:	d3 2e       	mov	r13, r19
        waitspi();
        // write data
        SPDR = data;
     6b6:	20 e8       	ldi	r18, 0x80	; 128
     6b8:	f2 2e       	mov	r15, r18

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     6ba:	9f eb       	ldi	r25, 0xBF	; 191
     6bc:	e9 2e       	mov	r14, r25
     6be:	15 c0       	rjmp	.+42     	; 0x6ea <enc28j60PacketSend+0x4a>
{
        // Check no transmit in progress
        while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
        {
                // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
                if( (enc28j60Read(EIR) & EIR_TXERIF) ) {
     6c0:	8c e1       	ldi	r24, 0x1C	; 28
     6c2:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
     6c6:	81 ff       	sbrs	r24, 1
     6c8:	10 c0       	rjmp	.+32     	; 0x6ea <enc28j60PacketSend+0x4a>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     6ca:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     6cc:	df b8       	out	0x0f, r13	; 15
        waitspi();
     6ce:	77 9b       	sbis	0x0e, 7	; 14
     6d0:	fe cf       	rjmp	.-4      	; 0x6ce <enc28j60PacketSend+0x2e>
        // write data
        SPDR = data;
     6d2:	ff b8       	out	0x0f, r15	; 15
        waitspi();
     6d4:	77 9b       	sbis	0x0e, 7	; 14
     6d6:	fe cf       	rjmp	.-4      	; 0x6d4 <enc28j60PacketSend+0x34>
        CSPASSIVE;
     6d8:	c4 9a       	sbi	0x18, 4	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     6da:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     6dc:	ef b8       	out	0x0f, r14	; 15
        waitspi();
     6de:	77 9b       	sbis	0x0e, 7	; 14
     6e0:	fe cf       	rjmp	.-4      	; 0x6de <enc28j60PacketSend+0x3e>
        // write data
        SPDR = data;
     6e2:	ff b8       	out	0x0f, r15	; 15
        waitspi();
     6e4:	77 9b       	sbis	0x0e, 7	; 14
     6e6:	fe cf       	rjmp	.-4      	; 0x6e4 <enc28j60PacketSend+0x44>
        CSPASSIVE;
     6e8:	c4 9a       	sbi	0x18, 4	; 24
}

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
        // Check no transmit in progress
        while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
     6ea:	80 e0       	ldi	r24, 0x00	; 0
     6ec:	6f e1       	ldi	r22, 0x1F	; 31
     6ee:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
     6f2:	83 fd       	sbrc	r24, 3
     6f4:	e5 cf       	rjmp	.-54     	; 0x6c0 <enc28j60PacketSend+0x20>
                        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
                        enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
                }
        }
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     6f6:	82 e0       	ldi	r24, 0x02	; 2
     6f8:	6f ef       	ldi	r22, 0xFF	; 255
     6fa:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     6fe:	83 e0       	ldi	r24, 0x03	; 3
     700:	69 e1       	ldi	r22, 0x19	; 25
     702:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     706:	ce 01       	movw	r24, r28
     708:	81 50       	subi	r24, 0x01	; 1
     70a:	68 2f       	mov	r22, r24
     70c:	86 e0       	ldi	r24, 0x06	; 6
     70e:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     712:	9e 01       	movw	r18, r28
     714:	21 50       	subi	r18, 0x01	; 1
     716:	36 4e       	sbci	r19, 0xE6	; 230
     718:	87 e0       	ldi	r24, 0x07	; 7
     71a:	63 2f       	mov	r22, r19
     71c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     720:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     722:	8a e7       	ldi	r24, 0x7A	; 122
     724:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     726:	77 9b       	sbis	0x0e, 7	; 14
     728:	fe cf       	rjmp	.-4      	; 0x726 <enc28j60PacketSend+0x86>
        // write data
        SPDR = data;
     72a:	1f b8       	out	0x0f, r1	; 15
        waitspi();
     72c:	77 9b       	sbis	0x0e, 7	; 14
     72e:	fe cf       	rjmp	.-4      	; 0x72c <enc28j60PacketSend+0x8c>
        CSPASSIVE;
     730:	c4 9a       	sbi	0x18, 4	; 24
        CSPASSIVE;
}

void enc28j60WriteBuffer(uint16_t len, uint8_t* data)
{
        CSACTIVE;
     732:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
     734:	8a e7       	ldi	r24, 0x7A	; 122
     736:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     738:	77 9b       	sbis	0x0e, 7	; 14
     73a:	fe cf       	rjmp	.-4      	; 0x738 <enc28j60PacketSend+0x98>
     73c:	08 c0       	rjmp	.+16     	; 0x74e <enc28j60PacketSend+0xae>
        while(len)
        {
                len--;
                // write data
                SPDR = *data;
     73e:	f8 01       	movw	r30, r16
     740:	80 81       	ld	r24, Z
     742:	8f b9       	out	0x0f, r24	; 15
                data++;
                waitspi();
     744:	77 9b       	sbis	0x0e, 7	; 14
     746:	fe cf       	rjmp	.-4      	; 0x744 <enc28j60PacketSend+0xa4>
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
        {
                len--;
     748:	21 97       	sbiw	r28, 0x01	; 1
                // write data
                SPDR = *data;
                data++;
     74a:	0f 5f       	subi	r16, 0xFF	; 255
     74c:	1f 4f       	sbci	r17, 0xFF	; 255
{
        CSACTIVE;
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
     74e:	20 97       	sbiw	r28, 0x00	; 0
     750:	b1 f7       	brne	.-20     	; 0x73e <enc28j60PacketSend+0x9e>
                // write data
                SPDR = *data;
                data++;
                waitspi();
        }
        CSPASSIVE;
     752:	c4 9a       	sbi	0x18, 4	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     754:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     756:	8f e9       	ldi	r24, 0x9F	; 159
     758:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     75a:	77 9b       	sbis	0x0e, 7	; 14
     75c:	fe cf       	rjmp	.-4      	; 0x75a <enc28j60PacketSend+0xba>
        // write data
        SPDR = data;
     75e:	88 e0       	ldi	r24, 0x08	; 8
     760:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     762:	77 9b       	sbis	0x0e, 7	; 14
     764:	fe cf       	rjmp	.-4      	; 0x762 <enc28j60PacketSend+0xc2>
        CSPASSIVE;
     766:	c4 9a       	sbi	0x18, 4	; 24
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
}
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	1f 91       	pop	r17
     76e:	0f 91       	pop	r16
     770:	ff 90       	pop	r15
     772:	ef 90       	pop	r14
     774:	df 90       	pop	r13
     776:	08 95       	ret

00000778 <enc28j60hasRxPkt>:

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
	if( enc28j60Read(EPKTCNT) ==0 ){
     778:	89 e3       	ldi	r24, 0x39	; 57
     77a:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
     77e:	81 11       	cpse	r24, r1
     780:	81 e0       	ldi	r24, 0x01	; 1
		return(0);
        }
        return(1);
}
     782:	08 95       	ret

00000784 <enc28j60PacketReceive>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     784:	8f 92       	push	r8
     786:	9f 92       	push	r9
     788:	af 92       	push	r10
     78a:	bf 92       	push	r11
     78c:	cf 92       	push	r12
     78e:	df 92       	push	r13
     790:	ef 92       	push	r14
     792:	ff 92       	push	r15
     794:	0f 93       	push	r16
     796:	1f 93       	push	r17
     798:	cf 93       	push	r28
     79a:	df 93       	push	r29
     79c:	5c 01       	movw	r10, r24
     79e:	4b 01       	movw	r8, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     7a0:	89 e3       	ldi	r24, 0x39	; 57
     7a2:	0e 94 31 02 	call	0x462	; 0x462 <enc28j60Read>
     7a6:	88 23       	and	r24, r24
     7a8:	19 f4       	brne	.+6      	; 0x7b0 <enc28j60PacketReceive+0x2c>
     7aa:	c0 e0       	ldi	r28, 0x00	; 0
     7ac:	d0 e0       	ldi	r29, 0x00	; 0
     7ae:	76 c0       	rjmp	.+236    	; 0x89c <__stack+0x3d>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (gNextPacketPtr &0xFF));
     7b0:	60 91 ad 00 	lds	r22, 0x00AD
     7b4:	10 91 ae 00 	lds	r17, 0x00AE
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ERDPTH, (gNextPacketPtr)>>8);
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	61 2f       	mov	r22, r17
     7c2:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	// read the next packet pointer
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     7c6:	8a e3       	ldi	r24, 0x3A	; 58
     7c8:	60 e0       	ldi	r22, 0x00	; 0
     7ca:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
     7ce:	18 2f       	mov	r17, r24
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     7d0:	8a e3       	ldi	r24, 0x3A	; 58
     7d2:	60 e0       	ldi	r22, 0x00	; 0
     7d4:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
     7d8:	38 2f       	mov	r19, r24
     7da:	20 e0       	ldi	r18, 0x00	; 0
     7dc:	e1 2e       	mov	r14, r17
     7de:	ff 24       	eor	r15, r15
     7e0:	e2 2a       	or	r14, r18
     7e2:	f3 2a       	or	r15, r19
     7e4:	f0 92 ae 00 	sts	0x00AE, r15
     7e8:	e0 92 ad 00 	sts	0x00AD, r14
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     7ec:	8a e3       	ldi	r24, 0x3A	; 58
     7ee:	60 e0       	ldi	r22, 0x00	; 0
     7f0:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
     7f4:	c8 2e       	mov	r12, r24
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     7f6:	8a e3       	ldi	r24, 0x3A	; 58
     7f8:	60 e0       	ldi	r22, 0x00	; 0
     7fa:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
     7fe:	d8 2e       	mov	r13, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     800:	8a e3       	ldi	r24, 0x3A	; 58
     802:	60 e0       	ldi	r22, 0x00	; 0
     804:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
     808:	08 2f       	mov	r16, r24
     80a:	10 e0       	ldi	r17, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     80c:	8a e3       	ldi	r24, 0x3A	; 58
     80e:	60 e0       	ldi	r22, 0x00	; 0
     810:	0e 94 c0 01 	call	0x380	; 0x380 <enc28j60ReadOp>
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     814:	38 2f       	mov	r19, r24
     816:	20 e0       	ldi	r18, 0x00	; 0
     818:	20 2b       	or	r18, r16
     81a:	31 2b       	or	r19, r17
     81c:	27 fd       	sbrc	r18, 7
     81e:	03 c0       	rjmp	.+6      	; 0x826 <enc28j60PacketReceive+0xa2>
     820:	c0 e0       	ldi	r28, 0x00	; 0
     822:	d0 e0       	ldi	r29, 0x00	; 0
     824:	11 c0       	rjmp	.+34     	; 0x848 <enc28j60PacketReceive+0xc4>
	enc28j60Write(ERDPTH, (gNextPacketPtr)>>8);
	// read the next packet pointer
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     826:	cc 2d       	mov	r28, r12
     828:	d0 e0       	ldi	r29, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     82a:	9d 2d       	mov	r25, r13
     82c:	80 e0       	ldi	r24, 0x00	; 0
     82e:	c8 2b       	or	r28, r24
     830:	d9 2b       	or	r29, r25
        len-=4; //remove the CRC count
     832:	c5 01       	movw	r24, r10
     834:	01 97       	sbiw	r24, 0x01	; 1
     836:	24 97       	sbiw	r28, 0x04	; 4
     838:	8c 17       	cp	r24, r28
     83a:	9d 07       	cpc	r25, r29
     83c:	08 f4       	brcc	.+2      	; 0x840 <enc28j60PacketReceive+0xbc>
     83e:	ec 01       	movw	r28, r24
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     840:	ce 01       	movw	r24, r28
     842:	b4 01       	movw	r22, r8
     844:	0e 94 dd 01 	call	0x3ba	; 0x3ba <enc28j60ReadBuffer>
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (gNextPacketPtr &0xFF));
     848:	de 2c       	mov	r13, r14
     84a:	8c e0       	ldi	r24, 0x0C	; 12
     84c:	6e 2d       	mov	r22, r14
     84e:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
	enc28j60Write(ERXRDPTH, (gNextPacketPtr)>>8);
     852:	8d e0       	ldi	r24, 0x0D	; 13
     854:	6f 2d       	mov	r22, r15
     856:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        // Move the RX read pointer to the start of the next received packet
        // This frees the memory we just read out.
        // However, compensate for the errata point 13, rev B4: enver write an even address!
        if ((gNextPacketPtr - 1 < RXSTART_INIT)
     85a:	87 01       	movw	r16, r14
     85c:	01 50       	subi	r16, 0x01	; 1
     85e:	10 40       	sbci	r17, 0x00	; 0
     860:	89 e1       	ldi	r24, 0x19	; 25
     862:	0f 3f       	cpi	r16, 0xFF	; 255
     864:	18 07       	cpc	r17, r24
     866:	38 f0       	brcs	.+14     	; 0x876 <__stack+0x17>
                || (gNextPacketPtr -1 > RXSTOP_INIT)) {
                enc28j60Write(ERXRDPTL, (RXSTOP_INIT)&0xFF);
     868:	8c e0       	ldi	r24, 0x0C	; 12
     86a:	6e ef       	ldi	r22, 0xFE	; 254
     86c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
                enc28j60Write(ERXRDPTH, (RXSTOP_INIT)>>8);
     870:	8d e0       	ldi	r24, 0x0D	; 13
     872:	69 e1       	ldi	r22, 0x19	; 25
     874:	07 c0       	rjmp	.+14     	; 0x884 <__stack+0x25>
        } else {
                enc28j60Write(ERXRDPTL, (gNextPacketPtr-1)&0xFF);
     876:	da 94       	dec	r13
     878:	8c e0       	ldi	r24, 0x0C	; 12
     87a:	6d 2d       	mov	r22, r13
     87c:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
                enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
     880:	8d e0       	ldi	r24, 0x0D	; 13
     882:	61 2f       	mov	r22, r17
     884:	0e 94 3b 02 	call	0x476	; 0x476 <enc28j60Write>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
     888:	c4 98       	cbi	0x18, 4	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
     88a:	8e e9       	ldi	r24, 0x9E	; 158
     88c:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     88e:	77 9b       	sbis	0x0e, 7	; 14
     890:	fe cf       	rjmp	.-4      	; 0x88e <__stack+0x2f>
        // write data
        SPDR = data;
     892:	80 e4       	ldi	r24, 0x40	; 64
     894:	8f b9       	out	0x0f, r24	; 15
        waitspi();
     896:	77 9b       	sbis	0x0e, 7	; 14
     898:	fe cf       	rjmp	.-4      	; 0x896 <__stack+0x37>
        CSPASSIVE;
     89a:	c4 9a       	sbi	0x18, 4	; 24
                enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
        }
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     89c:	ce 01       	movw	r24, r28
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	1f 91       	pop	r17
     8a4:	0f 91       	pop	r16
     8a6:	ff 90       	pop	r15
     8a8:	ef 90       	pop	r14
     8aa:	df 90       	pop	r13
     8ac:	cf 90       	pop	r12
     8ae:	bf 90       	pop	r11
     8b0:	af 90       	pop	r10
     8b2:	9f 90       	pop	r9
     8b4:	8f 90       	pop	r8
     8b6:	08 95       	ret

000008b8 <checksum>:
//
// For more information on how this algorithm works see:
// http://www.netfor2.com/checksum.html
// http://www.msc.uky.edu/ken/cs471/notes/chap3.htm
// The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
uint16_t checksum(uint8_t *buf, uint16_t len,uint8_t type){
     8b8:	cf 92       	push	r12
     8ba:	df 92       	push	r13
     8bc:	ef 92       	push	r14
     8be:	ff 92       	push	r15
     8c0:	0f 93       	push	r16
     8c2:	1f 93       	push	r17
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
     8c8:	6c 01       	movw	r12, r24
        uint32_t sum = 0;

        //if(type==0){
        //        // do not add anything
        //}
        if(type==1){
     8ca:	41 30       	cpi	r20, 0x01	; 1
     8cc:	81 f4       	brne	.+32     	; 0x8ee <checksum+0x36>
                sum+=IP_PROTO_UDP_V; // protocol udp
                // the length here is the length of udp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
     8ce:	68 50       	subi	r22, 0x08	; 8
     8d0:	70 40       	sbci	r23, 0x00	; 0
     8d2:	7b 01       	movw	r14, r22
     8d4:	00 e0       	ldi	r16, 0x00	; 0
     8d6:	10 e0       	ldi	r17, 0x00	; 0
     8d8:	68 5f       	subi	r22, 0xF8	; 248
     8da:	7f 4f       	sbci	r23, 0xFF	; 255
     8dc:	21 e1       	ldi	r18, 0x11	; 17
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	e2 0e       	add	r14, r18
     8e6:	f3 1e       	adc	r15, r19
     8e8:	04 1f       	adc	r16, r20
     8ea:	15 1f       	adc	r17, r21
     8ec:	15 c0       	rjmp	.+42     	; 0x918 <checksum+0x60>
        }
        if(type==2){
     8ee:	42 30       	cpi	r20, 0x02	; 2
     8f0:	21 f0       	breq	.+8      	; 0x8fa <checksum+0x42>
     8f2:	ee 24       	eor	r14, r14
     8f4:	ff 24       	eor	r15, r15
     8f6:	87 01       	movw	r16, r14
     8f8:	0f c0       	rjmp	.+30     	; 0x918 <checksum+0x60>
                sum+=IP_PROTO_TCP_V; 
                // the length here is the length of tcp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
     8fa:	68 50       	subi	r22, 0x08	; 8
     8fc:	70 40       	sbci	r23, 0x00	; 0
     8fe:	7b 01       	movw	r14, r22
     900:	00 e0       	ldi	r16, 0x00	; 0
     902:	10 e0       	ldi	r17, 0x00	; 0
     904:	68 5f       	subi	r22, 0xF8	; 248
     906:	7f 4f       	sbci	r23, 0xFF	; 255
     908:	86 e0       	ldi	r24, 0x06	; 6
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	a0 e0       	ldi	r26, 0x00	; 0
     90e:	b0 e0       	ldi	r27, 0x00	; 0
     910:	e8 0e       	add	r14, r24
     912:	f9 1e       	adc	r15, r25
     914:	0a 1f       	adc	r16, r26
     916:	1b 1f       	adc	r17, r27
     918:	f6 01       	movw	r30, r12
     91a:	eb 01       	movw	r28, r22
     91c:	16 c0       	rjmp	.+44     	; 0x94a <checksum+0x92>
        }
        // build the sum of 16bit words
        while(len >1){
                sum += 0xFFFF & (((uint32_t)*buf<<8)|*(buf+1));
     91e:	80 81       	ld	r24, Z
     920:	90 e0       	ldi	r25, 0x00	; 0
     922:	a0 e0       	ldi	r26, 0x00	; 0
     924:	b0 e0       	ldi	r27, 0x00	; 0
     926:	ba 2f       	mov	r27, r26
     928:	a9 2f       	mov	r26, r25
     92a:	98 2f       	mov	r25, r24
     92c:	88 27       	eor	r24, r24
     92e:	21 81       	ldd	r18, Z+1	; 0x01
     930:	30 e0       	ldi	r19, 0x00	; 0
     932:	40 e0       	ldi	r20, 0x00	; 0
     934:	50 e0       	ldi	r21, 0x00	; 0
     936:	82 2b       	or	r24, r18
     938:	93 2b       	or	r25, r19
     93a:	a4 2b       	or	r26, r20
     93c:	b5 2b       	or	r27, r21
     93e:	e8 0e       	add	r14, r24
     940:	f9 1e       	adc	r15, r25
     942:	0a 1f       	adc	r16, r26
     944:	1b 1f       	adc	r17, r27
                buf+=2;
     946:	32 96       	adiw	r30, 0x02	; 2
                len-=2;
     948:	22 97       	sbiw	r28, 0x02	; 2
                // the length here is the length of tcp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
        }
        // build the sum of 16bit words
        while(len >1){
     94a:	c2 30       	cpi	r28, 0x02	; 2
     94c:	d1 05       	cpc	r29, r1
     94e:	38 f7       	brcc	.-50     	; 0x91e <checksum+0x66>
     950:	fb 01       	movw	r30, r22
     952:	ee 7f       	andi	r30, 0xFE	; 254
     954:	ec 0d       	add	r30, r12
     956:	fd 1d       	adc	r31, r13
                sum += 0xFFFF & (((uint32_t)*buf<<8)|*(buf+1));
                buf+=2;
                len-=2;
        }
        // if there is a byte left then add it (padded with zero)
        if (len){
     958:	60 ff       	sbrs	r22, 0
     95a:	15 c0       	rjmp	.+42     	; 0x986 <checksum+0xce>
                sum += ((uint32_t)(0xFF & *buf))<<8;
     95c:	80 81       	ld	r24, Z
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	a0 e0       	ldi	r26, 0x00	; 0
     962:	b0 e0       	ldi	r27, 0x00	; 0
     964:	ba 2f       	mov	r27, r26
     966:	a9 2f       	mov	r26, r25
     968:	98 2f       	mov	r25, r24
     96a:	88 27       	eor	r24, r24
     96c:	08 c0       	rjmp	.+16     	; 0x97e <checksum+0xc6>
        }
        // now calculate the sum over the bytes in the sum
        // until the result is only 16bit long
        while (sum>>16){
                sum = (sum & 0xFFFF)+(sum >> 16);
     96e:	2f ef       	ldi	r18, 0xFF	; 255
     970:	3f ef       	ldi	r19, 0xFF	; 255
     972:	40 e0       	ldi	r20, 0x00	; 0
     974:	50 e0       	ldi	r21, 0x00	; 0
     976:	e2 22       	and	r14, r18
     978:	f3 22       	and	r15, r19
     97a:	04 23       	and	r16, r20
     97c:	15 23       	and	r17, r21
     97e:	e8 0e       	add	r14, r24
     980:	f9 1e       	adc	r15, r25
     982:	0a 1f       	adc	r16, r26
     984:	1b 1f       	adc	r17, r27
        if (len){
                sum += ((uint32_t)(0xFF & *buf))<<8;
        }
        // now calculate the sum over the bytes in the sum
        // until the result is only 16bit long
        while (sum>>16){
     986:	c8 01       	movw	r24, r16
     988:	aa 27       	eor	r26, r26
     98a:	bb 27       	eor	r27, r27
     98c:	00 97       	sbiw	r24, 0x00	; 0
     98e:	a1 05       	cpc	r26, r1
     990:	b1 05       	cpc	r27, r1
     992:	69 f7       	brne	.-38     	; 0x96e <checksum+0xb6>
     994:	97 01       	movw	r18, r14
     996:	20 95       	com	r18
     998:	30 95       	com	r19
                sum = (sum & 0xFFFF)+(sum >> 16);
        }
        // build 1's complement:
        return( (uint16_t) sum ^ 0xFFFF);
}
     99a:	c9 01       	movw	r24, r18
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	1f 91       	pop	r17
     9a2:	0f 91       	pop	r16
     9a4:	ff 90       	pop	r15
     9a6:	ef 90       	pop	r14
     9a8:	df 90       	pop	r13
     9aa:	cf 90       	pop	r12
     9ac:	08 95       	ret

000009ae <init_ip_arp_udp_tcp>:

// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint8_t wwwp){
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	ec 01       	movw	r28, r24
        uint8_t i=0;
        wwwport=wwwp;
     9b4:	40 93 a5 00 	sts	0x00A5, r20
     9b8:	20 e0       	ldi	r18, 0x00	; 0
     9ba:	30 e0       	ldi	r19, 0x00	; 0
        while(i<4){
                ipaddr[i]=myip[i];
     9bc:	f9 01       	movw	r30, r18
     9be:	eb 54       	subi	r30, 0x4B	; 75
     9c0:	ff 4f       	sbci	r31, 0xFF	; 255
     9c2:	db 01       	movw	r26, r22
     9c4:	a2 0f       	add	r26, r18
     9c6:	b3 1f       	adc	r27, r19
     9c8:	8c 91       	ld	r24, X
     9ca:	80 83       	st	Z, r24
     9cc:	2f 5f       	subi	r18, 0xFF	; 255
     9ce:	3f 4f       	sbci	r19, 0xFF	; 255

// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint8_t wwwp){
        uint8_t i=0;
        wwwport=wwwp;
        while(i<4){
     9d0:	24 30       	cpi	r18, 0x04	; 4
     9d2:	31 05       	cpc	r19, r1
     9d4:	99 f7       	brne	.-26     	; 0x9bc <init_ip_arp_udp_tcp+0xe>
     9d6:	20 e0       	ldi	r18, 0x00	; 0
     9d8:	30 e0       	ldi	r19, 0x00	; 0
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
                macaddr[i]=mymac[i];
     9da:	f9 01       	movw	r30, r18
     9dc:	e1 55       	subi	r30, 0x51	; 81
     9de:	ff 4f       	sbci	r31, 0xFF	; 255
     9e0:	de 01       	movw	r26, r28
     9e2:	a2 0f       	add	r26, r18
     9e4:	b3 1f       	adc	r27, r19
     9e6:	8c 91       	ld	r24, X
     9e8:	80 83       	st	Z, r24
     9ea:	2f 5f       	subi	r18, 0xFF	; 255
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
        while(i<4){
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
     9ee:	26 30       	cpi	r18, 0x06	; 6
     9f0:	31 05       	cpc	r19, r1
     9f2:	99 f7       	brne	.-26     	; 0x9da <init_ip_arp_udp_tcp+0x2c>
                macaddr[i]=mymac[i];
                i++;
        }
}
     9f4:	df 91       	pop	r29
     9f6:	cf 91       	pop	r28
     9f8:	08 95       	ret

000009fa <eth_type_is_arp_and_my_ip>:

uint8_t eth_type_is_arp_and_my_ip(uint8_t *buf,uint16_t len){
     9fa:	fc 01       	movw	r30, r24
        uint8_t i=0;
        //  
        if (len<41){
     9fc:	69 32       	cpi	r22, 0x29	; 41
     9fe:	71 05       	cpc	r23, r1
     a00:	b0 f0       	brcs	.+44     	; 0xa2e <eth_type_is_arp_and_my_ip+0x34>
                return(0);
        }
        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || 
     a02:	84 85       	ldd	r24, Z+12	; 0x0c
     a04:	88 30       	cpi	r24, 0x08	; 8
     a06:	99 f4       	brne	.+38     	; 0xa2e <eth_type_is_arp_and_my_ip+0x34>
     a08:	85 85       	ldd	r24, Z+13	; 0x0d
     a0a:	86 30       	cpi	r24, 0x06	; 6
     a0c:	81 f4       	brne	.+32     	; 0xa2e <eth_type_is_arp_and_my_ip+0x34>
     a0e:	df 01       	movw	r26, r30
     a10:	96 96       	adiw	r26, 0x26	; 38
     a12:	e5 eb       	ldi	r30, 0xB5	; 181
     a14:	f0 e0       	ldi	r31, 0x00	; 0
           buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V){
                return(0);
        }
        while(i<4){
                if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i]){
     a16:	9c 91       	ld	r25, X
     a18:	80 81       	ld	r24, Z
     a1a:	98 17       	cp	r25, r24
     a1c:	41 f4       	brne	.+16     	; 0xa2e <eth_type_is_arp_and_my_ip+0x34>
     a1e:	11 96       	adiw	r26, 0x01	; 1
     a20:	31 96       	adiw	r30, 0x01	; 1
        }
        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || 
           buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V){
                return(0);
        }
        while(i<4){
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	e9 3b       	cpi	r30, 0xB9	; 185
     a26:	f8 07       	cpc	r31, r24
     a28:	b1 f7       	brne	.-20     	; 0xa16 <eth_type_is_arp_and_my_ip+0x1c>
     a2a:	81 e0       	ldi	r24, 0x01	; 1
     a2c:	08 95       	ret
     a2e:	80 e0       	ldi	r24, 0x00	; 0
                        return(0);
                }
                i++;
        }
        return(1);
}
     a30:	08 95       	ret

00000a32 <eth_type_is_ip_and_my_ip>:

uint8_t eth_type_is_ip_and_my_ip(uint8_t *buf,uint16_t len){
     a32:	fc 01       	movw	r30, r24
        uint8_t i=0;
        //eth+ip+udp header is 42
        if (len<42){
     a34:	6a 32       	cpi	r22, 0x2A	; 42
     a36:	71 05       	cpc	r23, r1
     a38:	d0 f0       	brcs	.+52     	; 0xa6e <eth_type_is_ip_and_my_ip+0x3c>
                return(0);
        }
        if(buf[ETH_TYPE_H_P]!=ETHTYPE_IP_H_V || 
     a3a:	84 85       	ldd	r24, Z+12	; 0x0c
     a3c:	88 30       	cpi	r24, 0x08	; 8
     a3e:	b9 f4       	brne	.+46     	; 0xa6e <eth_type_is_ip_and_my_ip+0x3c>
     a40:	85 85       	ldd	r24, Z+13	; 0x0d
     a42:	88 23       	and	r24, r24
     a44:	a1 f4       	brne	.+40     	; 0xa6e <eth_type_is_ip_and_my_ip+0x3c>
           buf[ETH_TYPE_L_P]!=ETHTYPE_IP_L_V){
                return(0);
        }
        if (buf[IP_HEADER_LEN_VER_P]!=0x45){
     a46:	86 85       	ldd	r24, Z+14	; 0x0e
     a48:	85 34       	cpi	r24, 0x45	; 69
     a4a:	89 f4       	brne	.+34     	; 0xa6e <eth_type_is_ip_and_my_ip+0x3c>
     a4c:	df 01       	movw	r26, r30
     a4e:	e5 eb       	ldi	r30, 0xB5	; 181
     a50:	f0 e0       	ldi	r31, 0x00	; 0
                // must be IP V4 and 20 byte header
                return(0);
        }
        while(i<4){
                if(buf[IP_DST_P+i]!=ipaddr[i]){
     a52:	5e 96       	adiw	r26, 0x1e	; 30
     a54:	9c 91       	ld	r25, X
     a56:	5e 97       	sbiw	r26, 0x1e	; 30
     a58:	80 81       	ld	r24, Z
     a5a:	98 17       	cp	r25, r24
     a5c:	41 f4       	brne	.+16     	; 0xa6e <eth_type_is_ip_and_my_ip+0x3c>
     a5e:	11 96       	adiw	r26, 0x01	; 1
     a60:	31 96       	adiw	r30, 0x01	; 1
        }
        if (buf[IP_HEADER_LEN_VER_P]!=0x45){
                // must be IP V4 and 20 byte header
                return(0);
        }
        while(i<4){
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	e9 3b       	cpi	r30, 0xB9	; 185
     a66:	f8 07       	cpc	r31, r24
     a68:	a1 f7       	brne	.-24     	; 0xa52 <eth_type_is_ip_and_my_ip+0x20>
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	08 95       	ret
     a6e:	80 e0       	ldi	r24, 0x00	; 0
                        return(0);
                }
                i++;
        }
        return(1);
}
     a70:	08 95       	ret

00000a72 <make_eth>:
// make a return eth header from a received eth packet
void make_eth(uint8_t *buf)
{
     a72:	fc 01       	movw	r30, r24
     a74:	af ea       	ldi	r26, 0xAF	; 175
     a76:	b0 e0       	ldi	r27, 0x00	; 0
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
     a78:	86 81       	ldd	r24, Z+6	; 0x06
     a7a:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
     a7c:	8d 91       	ld	r24, X+
     a7e:	86 83       	std	Z+6, r24	; 0x06
     a80:	31 96       	adiw	r30, 0x01	; 1
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
     a82:	80 e0       	ldi	r24, 0x00	; 0
     a84:	a5 3b       	cpi	r26, 0xB5	; 181
     a86:	b8 07       	cpc	r27, r24
     a88:	b9 f7       	brne	.-18     	; 0xa78 <make_eth+0x6>
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
}
     a8a:	08 95       	ret

00000a8c <fill_ip_hdr_checksum>:
void fill_ip_hdr_checksum(uint8_t *buf)
{
     a8c:	0f 93       	push	r16
     a8e:	1f 93       	push	r17
     a90:	8c 01       	movw	r16, r24
        uint16_t ck;
        // clear the 2 byte checksum
        buf[IP_CHECKSUM_P]=0;
     a92:	fc 01       	movw	r30, r24
     a94:	10 8e       	std	Z+24, r1	; 0x18
        buf[IP_CHECKSUM_P+1]=0;
     a96:	11 8e       	std	Z+25, r1	; 0x19
        buf[IP_FLAGS_P]=0x40; // don't fragment
     a98:	80 e4       	ldi	r24, 0x40	; 64
     a9a:	84 8b       	std	Z+20, r24	; 0x14
        buf[IP_FLAGS_P+1]=0;  // fragement offset
     a9c:	15 8a       	std	Z+21, r1	; 0x15
        buf[IP_TTL_P]=64; // ttl
     a9e:	86 8b       	std	Z+22, r24	; 0x16
        // calculate the checksum:
        ck=checksum(&buf[IP_P], IP_HEADER_LEN,0);
     aa0:	c8 01       	movw	r24, r16
     aa2:	0e 96       	adiw	r24, 0x0e	; 14
     aa4:	64 e1       	ldi	r22, 0x14	; 20
     aa6:	70 e0       	ldi	r23, 0x00	; 0
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <checksum>
        buf[IP_CHECKSUM_P]=ck>>8;
     aae:	f8 01       	movw	r30, r16
     ab0:	90 8f       	std	Z+24, r25	; 0x18
        buf[IP_CHECKSUM_P+1]=ck& 0xff;
     ab2:	81 8f       	std	Z+25, r24	; 0x19
}
     ab4:	1f 91       	pop	r17
     ab6:	0f 91       	pop	r16
     ab8:	08 95       	ret

00000aba <make_ip>:

// make a return ip header from a received ip packet
void make_ip(uint8_t *buf)
{
     aba:	ac 01       	movw	r20, r24
     abc:	fc 01       	movw	r30, r24
     abe:	a5 eb       	ldi	r26, 0xB5	; 181
     ac0:	b0 e0       	ldi	r27, 0x00	; 0
        uint8_t i=0;
        while(i<4){
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
     ac2:	82 8d       	ldd	r24, Z+26	; 0x1a
     ac4:	86 8f       	std	Z+30, r24	; 0x1e
                buf[IP_SRC_P+i]=ipaddr[i];
     ac6:	8d 91       	ld	r24, X+
     ac8:	82 8f       	std	Z+26, r24	; 0x1a
     aca:	31 96       	adiw	r30, 0x01	; 1

// make a return ip header from a received ip packet
void make_ip(uint8_t *buf)
{
        uint8_t i=0;
        while(i<4){
     acc:	80 e0       	ldi	r24, 0x00	; 0
     ace:	a9 3b       	cpi	r26, 0xB9	; 185
     ad0:	b8 07       	cpc	r27, r24
     ad2:	b9 f7       	brne	.-18     	; 0xac2 <make_ip+0x8>
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
                buf[IP_SRC_P+i]=ipaddr[i];
                i++;
        }
        fill_ip_hdr_checksum(buf);
     ad4:	ca 01       	movw	r24, r20
     ad6:	0e 94 46 05 	call	0xa8c	; 0xa8c <fill_ip_hdr_checksum>
}
     ada:	08 95       	ret

00000adc <make_tcphead>:
//
// After calling this function you can fill in the first data byte at TCP_OPTIONS_P+4
// If cp_seq=0 then an initial sequence number is used (should be use in synack)
// otherwise it is copied from the packet we received
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t mss,uint8_t cp_seq)
{
     adc:	fc 01       	movw	r30, r24
        uint8_t i=0;
        uint8_t tseq;
        while(i<2){
                buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
     ade:	82 a1       	ldd	r24, Z+34	; 0x22
     ae0:	84 a3       	std	Z+36, r24	; 0x24
                buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
     ae2:	12 a2       	std	Z+34, r1	; 0x22
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t mss,uint8_t cp_seq)
{
        uint8_t i=0;
        uint8_t tseq;
        while(i<2){
                buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
     ae4:	83 a1       	ldd	r24, Z+35	; 0x23
     ae6:	85 a3       	std	Z+37, r24	; 0x25
                buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
     ae8:	13 a2       	std	Z+35, r1	; 0x23
                i++;
        }
        // set source port  (http):
        buf[TCP_SRC_PORT_L_P]=wwwport;
     aea:	80 91 a5 00 	lds	r24, 0x00A5
     aee:	83 a3       	std	Z+35, r24	; 0x23
//
// After calling this function you can fill in the first data byte at TCP_OPTIONS_P+4
// If cp_seq=0 then an initial sequence number is used (should be use in synack)
// otherwise it is copied from the packet we received
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t mss,uint8_t cp_seq)
{
     af0:	df 01       	movw	r26, r30
     af2:	99 96       	adiw	r26, 0x29	; 41
     af4:	94 e0       	ldi	r25, 0x04	; 4
        buf[TCP_SRC_PORT_L_P]=wwwport;
        i=4;
        // sequence numbers:
        // add the rel ack num to SEQACK
        while(i>0){
                rel_ack_num=buf[TCP_SEQ_H_P+i-1]+rel_ack_num;
     af6:	8c 91       	ld	r24, X
     af8:	68 0f       	add	r22, r24
     afa:	71 1d       	adc	r23, r1
                tseq=buf[TCP_SEQACK_H_P+i-1];
     afc:	14 96       	adiw	r26, 0x04	; 4
     afe:	8c 91       	ld	r24, X
     b00:	14 97       	sbiw	r26, 0x04	; 4
                buf[TCP_SEQACK_H_P+i-1]=0xff&rel_ack_num;
     b02:	14 96       	adiw	r26, 0x04	; 4
     b04:	6c 93       	st	X, r22
     b06:	14 97       	sbiw	r26, 0x04	; 4
                if (cp_seq){
     b08:	22 23       	and	r18, r18
     b0a:	11 f0       	breq	.+4      	; 0xb10 <make_tcphead+0x34>
                        // copy the acknum sent to us into the sequence number
                        buf[TCP_SEQ_H_P+i-1]=tseq;
     b0c:	8c 93       	st	X, r24
     b0e:	01 c0       	rjmp	.+2      	; 0xb12 <make_tcphead+0x36>
                }else{
                        buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
     b10:	1c 92       	st	X, r1
                }
                rel_ack_num=rel_ack_num>>8;
                i--;
     b12:	91 50       	subi	r25, 0x01	; 1
     b14:	11 97       	sbiw	r26, 0x01	; 1
        // set source port  (http):
        buf[TCP_SRC_PORT_L_P]=wwwport;
        i=4;
        // sequence numbers:
        // add the rel ack num to SEQACK
        while(i>0){
     b16:	99 23       	and	r25, r25
     b18:	19 f0       	breq	.+6      	; 0xb20 <make_tcphead+0x44>
                        // copy the acknum sent to us into the sequence number
                        buf[TCP_SEQ_H_P+i-1]=tseq;
                }else{
                        buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
                }
                rel_ack_num=rel_ack_num>>8;
     b1a:	67 2f       	mov	r22, r23
     b1c:	77 27       	eor	r23, r23
     b1e:	eb cf       	rjmp	.-42     	; 0xaf6 <make_tcphead+0x1a>
                i--;
        }
        if (cp_seq==0){
     b20:	22 23       	and	r18, r18
     b22:	49 f4       	brne	.+18     	; 0xb36 <make_tcphead+0x5a>
                // put inital seq number
                buf[TCP_SEQ_H_P+0]= 0;
     b24:	16 a2       	std	Z+38, r1	; 0x26
                buf[TCP_SEQ_H_P+1]= 0;
     b26:	17 a2       	std	Z+39, r1	; 0x27
                // we step only the second byte, this allows us to send packts 
                // with 255 bytes or 512 (if we step the initial seqnum by 2)
                buf[TCP_SEQ_H_P+2]= seqnum; 
     b28:	80 91 a6 00 	lds	r24, 0x00A6
     b2c:	80 a7       	std	Z+40, r24	; 0x28
                buf[TCP_SEQ_H_P+3]= 0;
     b2e:	11 a6       	std	Z+41, r1	; 0x29
                // step the inititial seq num by something we will not use
                // during this tcp session:
                seqnum+=2;
     b30:	8e 5f       	subi	r24, 0xFE	; 254
     b32:	80 93 a6 00 	sts	0x00A6, r24
        }
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
     b36:	12 aa       	std	Z+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
     b38:	13 aa       	std	Z+51, r1	; 0x33

        // The tcp header length is only a 4 bit field (the upper 4 bits).
        // It is calculated in units of 4 bytes. 
        // E.g 24 bytes: 24/4=6 => 0x60=header len field
        //buf[TCP_HEADER_LEN_P]=(((TCP_HEADER_LEN_PLAIN+4)/4)) <<4; // 0x60
        if (mss){
     b3a:	44 23       	and	r20, r20
     b3c:	51 f0       	breq	.+20     	; 0xb52 <make_tcphead+0x76>
                // the only option we set is MSS to 1408:
                // 1408 in hex is 0x580
                buf[TCP_OPTIONS_P]=2;
     b3e:	82 e0       	ldi	r24, 0x02	; 2
     b40:	86 ab       	std	Z+54, r24	; 0x36
                buf[TCP_OPTIONS_P+1]=4;
     b42:	84 e0       	ldi	r24, 0x04	; 4
     b44:	87 ab       	std	Z+55, r24	; 0x37
                buf[TCP_OPTIONS_P+2]=0x05; 
     b46:	85 e0       	ldi	r24, 0x05	; 5
     b48:	80 af       	std	Z+56, r24	; 0x38
                buf[TCP_OPTIONS_P+3]=0x80;
     b4a:	80 e8       	ldi	r24, 0x80	; 128
     b4c:	81 af       	std	Z+57, r24	; 0x39
                // 24 bytes:
                buf[TCP_HEADER_LEN_P]=0x60;
     b4e:	80 e6       	ldi	r24, 0x60	; 96
     b50:	01 c0       	rjmp	.+2      	; 0xb54 <make_tcphead+0x78>
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
     b52:	80 e5       	ldi	r24, 0x50	; 80
     b54:	86 a7       	std	Z+46, r24	; 0x2e
     b56:	08 95       	ret

00000b58 <make_arp_answer_from_request>:
        }
}

void make_arp_answer_from_request(uint8_t *buf)
{
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	ac 01       	movw	r20, r24
     b5e:	ec 01       	movw	r28, r24
     b60:	2f ea       	ldi	r18, 0xAF	; 175
     b62:	30 e0       	ldi	r19, 0x00	; 0
     b64:	fc 01       	movw	r30, r24
     b66:	d9 01       	movw	r26, r18
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
     b68:	86 81       	ldd	r24, Z+6	; 0x06
     b6a:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
     b6c:	8d 91       	ld	r24, X+
     b6e:	86 83       	std	Z+6, r24	; 0x06
     b70:	31 96       	adiw	r30, 0x01	; 1
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	a5 3b       	cpi	r26, 0xB5	; 181
     b76:	b8 07       	cpc	r27, r24
     b78:	b9 f7       	brne	.-18     	; 0xb68 <make_arp_answer_from_request+0x10>
void make_arp_answer_from_request(uint8_t *buf)
{
        uint8_t i=0;
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
     b7a:	fa 01       	movw	r30, r20
     b7c:	14 8a       	std	Z+20, r1	; 0x14
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
     b7e:	82 e0       	ldi	r24, 0x02	; 2
     b80:	85 8b       	std	Z+21, r24	; 0x15
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
     b82:	8e 89       	ldd	r24, Y+22	; 0x16
     b84:	88 a3       	std	Y+32, r24	; 0x20
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
     b86:	f9 01       	movw	r30, r18
     b88:	81 91       	ld	r24, Z+
     b8a:	9f 01       	movw	r18, r30
     b8c:	8e 8b       	std	Y+22, r24	; 0x16
     b8e:	21 96       	adiw	r28, 0x01	; 1
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	25 3b       	cpi	r18, 0xB5	; 181
     b94:	3f 07       	cpc	r19, r31
     b96:	a9 f7       	brne	.-22     	; 0xb82 <make_arp_answer_from_request+0x2a>
     b98:	fa 01       	movw	r30, r20
     b9a:	7c 96       	adiw	r30, 0x1c	; 28
     b9c:	a5 eb       	ldi	r26, 0xB5	; 181
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
     ba0:	80 81       	ld	r24, Z
     ba2:	82 87       	std	Z+10, r24	; 0x0a
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
     ba4:	8d 91       	ld	r24, X+
     ba6:	81 93       	st	Z+, r24
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	a9 3b       	cpi	r26, 0xB9	; 185
     bac:	b8 07       	cpc	r27, r24
     bae:	c1 f7       	brne	.-16     	; 0xba0 <make_arp_answer_from_request+0x48>
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
     bb0:	8a e2       	ldi	r24, 0x2A	; 42
     bb2:	90 e0       	ldi	r25, 0x00	; 0
     bb4:	ba 01       	movw	r22, r20
     bb6:	0e 94 50 03 	call	0x6a0	; 0x6a0 <enc28j60PacketSend>
}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <make_echo_reply_from_request>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
     bc0:	0f 93       	push	r16
     bc2:	1f 93       	push	r17
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	ec 01       	movw	r28, r24
     bca:	8b 01       	movw	r16, r22
     bcc:	fc 01       	movw	r30, r24
     bce:	af ea       	ldi	r26, 0xAF	; 175
     bd0:	b0 e0       	ldi	r27, 0x00	; 0
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
     bd2:	86 81       	ldd	r24, Z+6	; 0x06
     bd4:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
     bd6:	8d 91       	ld	r24, X+
     bd8:	86 83       	std	Z+6, r24	; 0x06
     bda:	31 96       	adiw	r30, 0x01	; 1
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	a5 3b       	cpi	r26, 0xB5	; 181
     be0:	b8 07       	cpc	r27, r24
     be2:	b9 f7       	brne	.-18     	; 0xbd2 <make_echo_reply_from_request+0x12>
}

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
        make_eth(buf);
        make_ip(buf);
     be4:	ce 01       	movw	r24, r28
     be6:	0e 94 5d 05 	call	0xaba	; 0xaba <make_ip>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
     bea:	1a a2       	std	Y+34, r1	; 0x22
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
     bec:	8c a1       	ldd	r24, Y+36	; 0x24
     bee:	88 3f       	cpi	r24, 0xF8	; 248
     bf0:	18 f0       	brcs	.+6      	; 0xbf8 <make_echo_reply_from_request+0x38>
                buf[ICMP_CHECKSUM_P+1]++;
     bf2:	8d a1       	ldd	r24, Y+37	; 0x25
     bf4:	8f 5f       	subi	r24, 0xFF	; 255
     bf6:	8d a3       	std	Y+37, r24	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
     bf8:	8c a1       	ldd	r24, Y+36	; 0x24
     bfa:	88 5f       	subi	r24, 0xF8	; 248
     bfc:	8c a3       	std	Y+36, r24	; 0x24
        //
        enc28j60PacketSend(len,buf);
     bfe:	c8 01       	movw	r24, r16
     c00:	be 01       	movw	r22, r28
     c02:	0e 94 50 03 	call	0x6a0	; 0x6a0 <enc28j60PacketSend>
}
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	08 95       	ret

00000c10 <make_udp_reply_from_request>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
     c10:	df 92       	push	r13
     c12:	ef 92       	push	r14
     c14:	ff 92       	push	r15
     c16:	0f 93       	push	r16
     c18:	1f 93       	push	r17
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	ec 01       	movw	r28, r24
     c20:	7b 01       	movw	r14, r22
     c22:	d2 2e       	mov	r13, r18
     c24:	13 2f       	mov	r17, r19
     c26:	fc 01       	movw	r30, r24
     c28:	af ea       	ldi	r26, 0xAF	; 175
     c2a:	b0 e0       	ldi	r27, 0x00	; 0
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
     c2c:	86 81       	ldd	r24, Z+6	; 0x06
     c2e:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
     c30:	8d 91       	ld	r24, X+
     c32:	86 83       	std	Z+6, r24	; 0x06
     c34:	31 96       	adiw	r30, 0x01	; 1
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	a5 3b       	cpi	r26, 0xB5	; 181
     c3a:	b8 07       	cpc	r27, r24
     c3c:	b9 f7       	brne	.-18     	; 0xc2c <make_udp_reply_from_request+0x1c>
     c3e:	04 2f       	mov	r16, r20
     c40:	4d 3d       	cpi	r20, 0xDD	; 221
     c42:	08 f0       	brcs	.+2      	; 0xc46 <make_udp_reply_from_request+0x36>
     c44:	0c ed       	ldi	r16, 0xDC	; 220
        make_eth(buf);
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
     c46:	18 8a       	std	Y+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
     c48:	04 5e       	subi	r16, 0xE4	; 228
     c4a:	09 8b       	std	Y+17, r16	; 0x11
        make_ip(buf);
     c4c:	ce 01       	movw	r24, r28
     c4e:	0e 94 5d 05 	call	0xaba	; 0xaba <make_ip>
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
     c52:	8a a1       	ldd	r24, Y+34	; 0x22
     c54:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
     c56:	8b a1       	ldd	r24, Y+35	; 0x23
     c58:	8d a3       	std	Y+37, r24	; 0x25
        buf[UDP_SRC_PORT_H_P]=port>>8;
     c5a:	1a a3       	std	Y+34, r17	; 0x22
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
     c5c:	db a2       	std	Y+35, r13	; 0x23
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
     c5e:	1e a2       	std	Y+38, r1	; 0x26
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
     c60:	04 51       	subi	r16, 0x14	; 20
     c62:	0f a3       	std	Y+39, r16	; 0x27
     c64:	08 50       	subi	r16, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
     c66:	18 a6       	std	Y+40, r1	; 0x28
        buf[UDP_CHECKSUM_L_P]=0;
     c68:	19 a6       	std	Y+41, r1	; 0x29
     c6a:	de 01       	movw	r26, r28
     c6c:	9a 96       	adiw	r26, 0x2a	; 42
     c6e:	20 e0       	ldi	r18, 0x00	; 0
     c70:	30 e0       	ldi	r19, 0x00	; 0
     c72:	07 c0       	rjmp	.+14     	; 0xc82 <make_udp_reply_from_request+0x72>
        // copy the data:
        while(i<datalen){
                buf[UDP_DATA_P+i]=data[i];
     c74:	f7 01       	movw	r30, r14
     c76:	e2 0f       	add	r30, r18
     c78:	f3 1f       	adc	r31, r19
     c7a:	80 81       	ld	r24, Z
     c7c:	8d 93       	st	X+, r24
     c7e:	2f 5f       	subi	r18, 0xFF	; 255
     c80:	3f 4f       	sbci	r19, 0xFF	; 255
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
     c82:	20 17       	cp	r18, r16
     c84:	b8 f3       	brcs	.-18     	; 0xc74 <make_udp_reply_from_request+0x64>
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
     c86:	10 e0       	ldi	r17, 0x00	; 0
     c88:	00 5f       	subi	r16, 0xF0	; 240
     c8a:	1f 4f       	sbci	r17, 0xFF	; 255
     c8c:	ce 01       	movw	r24, r28
     c8e:	4a 96       	adiw	r24, 0x1a	; 26
     c90:	b8 01       	movw	r22, r16
     c92:	41 e0       	ldi	r20, 0x01	; 1
     c94:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <checksum>
        buf[UDP_CHECKSUM_H_P]=ck>>8;
     c98:	98 a7       	std	Y+40, r25	; 0x28
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
     c9a:	89 a7       	std	Y+41, r24	; 0x29
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
     c9c:	c8 01       	movw	r24, r16
     c9e:	4a 96       	adiw	r24, 0x1a	; 26
     ca0:	be 01       	movw	r22, r28
     ca2:	0e 94 50 03 	call	0x6a0	; 0x6a0 <enc28j60PacketSend>
}
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	ef 90       	pop	r14
     cb2:	df 90       	pop	r13
     cb4:	08 95       	ret

00000cb6 <make_tcp_synack_from_syn>:

void make_tcp_synack_from_syn(uint8_t *buf)
{
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	ec 01       	movw	r28, r24
     cbc:	fc 01       	movw	r30, r24
     cbe:	af ea       	ldi	r26, 0xAF	; 175
     cc0:	b0 e0       	ldi	r27, 0x00	; 0
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
     cc2:	86 81       	ldd	r24, Z+6	; 0x06
     cc4:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
     cc6:	8d 91       	ld	r24, X+
     cc8:	86 83       	std	Z+6, r24	; 0x06
     cca:	31 96       	adiw	r30, 0x01	; 1
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
     ccc:	80 e0       	ldi	r24, 0x00	; 0
     cce:	a5 3b       	cpi	r26, 0xB5	; 181
     cd0:	b8 07       	cpc	r27, r24
     cd2:	b9 f7       	brne	.-18     	; 0xcc2 <make_tcp_synack_from_syn+0xc>
{
        uint16_t ck;
        make_eth(buf);
        // total length field in the IP header must be set:
        // 20 bytes IP + 24 bytes (20tcp+4tcp options)
        buf[IP_TOTLEN_H_P]=0;
     cd4:	18 8a       	std	Y+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
     cd6:	8c e2       	ldi	r24, 0x2C	; 44
     cd8:	89 8b       	std	Y+17, r24	; 0x11
        make_ip(buf);
     cda:	ce 01       	movw	r24, r28
     cdc:	0e 94 5d 05 	call	0xaba	; 0xaba <make_ip>
        buf[TCP_FLAGS_P]=TCP_FLAGS_SYNACK_V;
     ce0:	82 e1       	ldi	r24, 0x12	; 18
     ce2:	8f a7       	std	Y+47, r24	; 0x2f
        make_tcphead(buf,1,1,0);
     ce4:	ce 01       	movw	r24, r28
     ce6:	61 e0       	ldi	r22, 0x01	; 1
     ce8:	70 e0       	ldi	r23, 0x00	; 0
     cea:	41 e0       	ldi	r20, 0x01	; 1
     cec:	20 e0       	ldi	r18, 0x00	; 0
     cee:	0e 94 6e 05 	call	0xadc	; 0xadc <make_tcphead>
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
        ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
     cf2:	ce 01       	movw	r24, r28
     cf4:	4a 96       	adiw	r24, 0x1a	; 26
     cf6:	60 e2       	ldi	r22, 0x20	; 32
     cf8:	70 e0       	ldi	r23, 0x00	; 0
     cfa:	42 e0       	ldi	r20, 0x02	; 2
     cfc:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <checksum>
        buf[TCP_CHECKSUM_H_P]=ck>>8;
     d00:	9a ab       	std	Y+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
     d02:	8b ab       	std	Y+51, r24	; 0x33
        // add 4 for option mss:
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
     d04:	8a e3       	ldi	r24, 0x3A	; 58
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	be 01       	movw	r22, r28
     d0a:	0e 94 50 03 	call	0x6a0	; 0x6a0 <enc28j60PacketSend>
}
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	08 95       	ret

00000d14 <get_tcp_data_pointer>:
// get a pointer to the start of tcp data in buf
// Returns 0 if there is no data
// You must call init_len_info once before calling this function
uint16_t get_tcp_data_pointer(void)
{
        if (info_data_len){
     d14:	80 91 a8 00 	lds	r24, 0x00A8
     d18:	90 91 a9 00 	lds	r25, 0x00A9
     d1c:	89 2b       	or	r24, r25
     d1e:	19 f4       	brne	.+6      	; 0xd26 <get_tcp_data_pointer+0x12>
     d20:	20 e0       	ldi	r18, 0x00	; 0
     d22:	30 e0       	ldi	r19, 0x00	; 0
     d24:	06 c0       	rjmp	.+12     	; 0xd32 <get_tcp_data_pointer+0x1e>
                return((uint16_t)TCP_SRC_PORT_H_P+info_hdr_len);
     d26:	20 91 aa 00 	lds	r18, 0x00AA
     d2a:	30 91 ab 00 	lds	r19, 0x00AB
     d2e:	2e 5d       	subi	r18, 0xDE	; 222
     d30:	3f 4f       	sbci	r19, 0xFF	; 255
        }else{
                return(0);
        }
}
     d32:	c9 01       	movw	r24, r18
     d34:	08 95       	ret

00000d36 <init_len_info>:

// do some basic length calculations and store the result in static varibales
void init_len_info(uint8_t *buf)
{
     d36:	fc 01       	movw	r30, r24
        info_data_len=(((int16_t)buf[IP_TOTLEN_H_P])<<8)|(buf[IP_TOTLEN_L_P]&0xff);
     d38:	90 89       	ldd	r25, Z+16	; 0x10
     d3a:	80 e0       	ldi	r24, 0x00	; 0
     d3c:	21 89       	ldd	r18, Z+17	; 0x11
     d3e:	30 e0       	ldi	r19, 0x00	; 0
     d40:	28 2b       	or	r18, r24
     d42:	39 2b       	or	r19, r25
        info_data_len-=IP_HEADER_LEN;
        info_hdr_len=(buf[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
     d44:	86 a5       	ldd	r24, Z+46	; 0x2e
     d46:	82 95       	swap	r24
     d48:	8f 70       	andi	r24, 0x0F	; 15
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	88 0f       	add	r24, r24
     d4e:	99 1f       	adc	r25, r25
     d50:	88 0f       	add	r24, r24
     d52:	99 1f       	adc	r25, r25
     d54:	90 93 ab 00 	sts	0x00AB, r25
     d58:	80 93 aa 00 	sts	0x00AA, r24
        info_data_len-=info_hdr_len;
     d5c:	24 51       	subi	r18, 0x14	; 20
     d5e:	30 40       	sbci	r19, 0x00	; 0
     d60:	28 1b       	sub	r18, r24
     d62:	39 0b       	sbc	r19, r25
     d64:	30 93 a9 00 	sts	0x00A9, r19
     d68:	20 93 a8 00 	sts	0x00A8, r18
        if (info_data_len<=0){
     d6c:	12 16       	cp	r1, r18
     d6e:	13 06       	cpc	r1, r19
     d70:	24 f0       	brlt	.+8      	; 0xd7a <init_len_info+0x44>
                info_data_len=0;
     d72:	10 92 a9 00 	sts	0x00A9, r1
     d76:	10 92 a8 00 	sts	0x00A8, r1
     d7a:	08 95       	ret

00000d7c <fill_tcp_data_p>:

// fill in tcp data at position pos. pos=0 means start of
// tcp data. Returns the position at which the string after
// this string could be filled.
uint16_t fill_tcp_data_p(uint8_t *buf,uint16_t pos, const prog_char *progmem_s)
{
     d7c:	6a 5c       	subi	r22, 0xCA	; 202
     d7e:	7f 4f       	sbci	r23, 0xFF	; 255
     d80:	dc 01       	movw	r26, r24
     d82:	a6 0f       	add	r26, r22
     d84:	b7 1f       	adc	r27, r23
     d86:	66 53       	subi	r22, 0x36	; 54
     d88:	70 40       	sbci	r23, 0x00	; 0
     d8a:	03 c0       	rjmp	.+6      	; 0xd92 <fill_tcp_data_p+0x16>
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
     d8c:	8d 93       	st	X+, r24
                pos++;
     d8e:	6f 5f       	subi	r22, 0xFF	; 255
     d90:	7f 4f       	sbci	r23, 0xFF	; 255
     d92:	fa 01       	movw	r30, r20
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
     d94:	4f 5f       	subi	r20, 0xFF	; 255
     d96:	5f 4f       	sbci	r21, 0xFF	; 255
     d98:	84 91       	lpm	r24, Z+
     d9a:	88 23       	and	r24, r24
     d9c:	b9 f7       	brne	.-18     	; 0xd8c <fill_tcp_data_p+0x10>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
                pos++;
        }
        return(pos);
}
     d9e:	cb 01       	movw	r24, r22
     da0:	08 95       	ret

00000da2 <fill_tcp_data>:

// fill in tcp data at position pos. pos=0 means start of
// tcp data. Returns the position at which the string after
// this string could be filled.
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
     da2:	fa 01       	movw	r30, r20
     da4:	6a 5c       	subi	r22, 0xCA	; 202
     da6:	7f 4f       	sbci	r23, 0xFF	; 255
     da8:	dc 01       	movw	r26, r24
     daa:	a6 0f       	add	r26, r22
     dac:	b7 1f       	adc	r27, r23
     dae:	66 53       	subi	r22, 0x36	; 54
     db0:	70 40       	sbci	r23, 0x00	; 0
     db2:	04 c0       	rjmp	.+8      	; 0xdbc <fill_tcp_data+0x1a>
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
     db4:	8d 93       	st	X+, r24
                pos++;
     db6:	6f 5f       	subi	r22, 0xFF	; 255
     db8:	7f 4f       	sbci	r23, 0xFF	; 255
                s++;
     dba:	31 96       	adiw	r30, 0x01	; 1
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
     dbc:	80 81       	ld	r24, Z
     dbe:	88 23       	and	r24, r24
     dc0:	c9 f7       	brne	.-14     	; 0xdb4 <fill_tcp_data+0x12>
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
                pos++;
                s++;
        }
        return(pos);
}
     dc2:	cb 01       	movw	r24, r22
     dc4:	08 95       	ret

00000dc6 <make_tcp_ack_from_any>:

// Make just an ack packet with no tcp data inside
// This will modify the eth/ip/tcp header 
void make_tcp_ack_from_any(uint8_t *buf)
{
     dc6:	cf 93       	push	r28
     dc8:	df 93       	push	r29
     dca:	ec 01       	movw	r28, r24
     dcc:	fc 01       	movw	r30, r24
     dce:	af ea       	ldi	r26, 0xAF	; 175
     dd0:	b0 e0       	ldi	r27, 0x00	; 0
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
     dd2:	86 81       	ldd	r24, Z+6	; 0x06
     dd4:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
     dd6:	8d 91       	ld	r24, X+
     dd8:	86 83       	std	Z+6, r24	; 0x06
     dda:	31 96       	adiw	r30, 0x01	; 1
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	a5 3b       	cpi	r26, 0xB5	; 181
     de0:	b8 07       	cpc	r27, r24
     de2:	b9 f7       	brne	.-18     	; 0xdd2 <make_tcp_ack_from_any+0xc>
void make_tcp_ack_from_any(uint8_t *buf)
{
        uint16_t j;
        make_eth(buf);
        // fill the header:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V;
     de4:	80 e1       	ldi	r24, 0x10	; 16
     de6:	8f a7       	std	Y+47, r24	; 0x2f
        if (info_data_len==0){
     de8:	60 91 a8 00 	lds	r22, 0x00A8
     dec:	70 91 a9 00 	lds	r23, 0x00A9
     df0:	61 15       	cp	r22, r1
     df2:	71 05       	cpc	r23, r1
     df4:	21 f4       	brne	.+8      	; 0xdfe <make_tcp_ack_from_any+0x38>
                // if there is no data then we must still acknoledge one packet
                make_tcphead(buf,1,0,1); // no options
     df6:	ce 01       	movw	r24, r28
     df8:	61 e0       	ldi	r22, 0x01	; 1
     dfa:	70 e0       	ldi	r23, 0x00	; 0
     dfc:	01 c0       	rjmp	.+2      	; 0xe00 <make_tcp_ack_from_any+0x3a>
        }else{
                make_tcphead(buf,info_data_len,0,1); // no options
     dfe:	ce 01       	movw	r24, r28
     e00:	40 e0       	ldi	r20, 0x00	; 0
     e02:	21 e0       	ldi	r18, 0x01	; 1
     e04:	0e 94 6e 05 	call	0xadc	; 0xadc <make_tcphead>
        }

        // total length field in the IP header must be set:
        // 20 bytes IP + 20 bytes tcp (when no options) 
        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
        buf[IP_TOTLEN_H_P]=j>>8;
     e08:	18 8a       	std	Y+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=j& 0xff;
     e0a:	88 e2       	ldi	r24, 0x28	; 40
     e0c:	89 8b       	std	Y+17, r24	; 0x11
        make_ip(buf);
     e0e:	ce 01       	movw	r24, r28
     e10:	0e 94 5d 05 	call	0xaba	; 0xaba <make_ip>
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
     e14:	ce 01       	movw	r24, r28
     e16:	4a 96       	adiw	r24, 0x1a	; 26
     e18:	6c e1       	ldi	r22, 0x1C	; 28
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	42 e0       	ldi	r20, 0x02	; 2
     e1e:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <checksum>
        buf[TCP_CHECKSUM_H_P]=j>>8;
     e22:	9a ab       	std	Y+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
     e24:	8b ab       	std	Y+51, r24	; 0x33
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
     e26:	86 e3       	ldi	r24, 0x36	; 54
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	be 01       	movw	r22, r28
     e2c:	0e 94 50 03 	call	0x6a0	; 0x6a0 <enc28j60PacketSend>
}
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	08 95       	ret

00000e36 <make_tcp_ack_with_data>:
// dlen is the amount of tcp data (http data) we send in this packet
// You can use this function only immediately after make_tcp_ack_from_any
// This is because this function will NOT modify the eth/ip/tcp header except for
// length and checksum
void make_tcp_ack_with_data(uint8_t *buf,uint16_t dlen)
{
     e36:	ef 92       	push	r14
     e38:	ff 92       	push	r15
     e3a:	0f 93       	push	r16
     e3c:	1f 93       	push	r17
     e3e:	8c 01       	movw	r16, r24
     e40:	7b 01       	movw	r14, r22
        uint16_t j;
        // fill the header:
        // This code requires that we send only one data packet
        // because we keep no state information. We must therefore set
        // the fin here:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
     e42:	89 e1       	ldi	r24, 0x19	; 25
     e44:	f8 01       	movw	r30, r16
     e46:	87 a7       	std	Z+47, r24	; 0x2f

        // total length field in the IP header must be set:
        // 20 bytes IP + 20 bytes tcp (when no options) + len of data
        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
     e48:	cb 01       	movw	r24, r22
     e4a:	88 96       	adiw	r24, 0x28	; 40
        buf[IP_TOTLEN_H_P]=j>>8;
     e4c:	90 8b       	std	Z+16, r25	; 0x10
        buf[IP_TOTLEN_L_P]=j& 0xff;
     e4e:	81 8b       	std	Z+17, r24	; 0x11
        fill_ip_hdr_checksum(buf);
     e50:	c8 01       	movw	r24, r16
     e52:	0e 94 46 05 	call	0xa8c	; 0xa8c <fill_ip_hdr_checksum>
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
     e56:	f8 01       	movw	r30, r16
     e58:	12 aa       	std	Z+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
     e5a:	13 aa       	std	Z+51, r1	; 0x33
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
     e5c:	8c e1       	ldi	r24, 0x1C	; 28
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	e8 0e       	add	r14, r24
     e62:	f9 1e       	adc	r15, r25
     e64:	c8 01       	movw	r24, r16
     e66:	4a 96       	adiw	r24, 0x1a	; 26
     e68:	b7 01       	movw	r22, r14
     e6a:	42 e0       	ldi	r20, 0x02	; 2
     e6c:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <checksum>
        buf[TCP_CHECKSUM_H_P]=j>>8;
     e70:	f8 01       	movw	r30, r16
     e72:	92 ab       	std	Z+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
     e74:	83 ab       	std	Z+51, r24	; 0x33
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
     e76:	c7 01       	movw	r24, r14
     e78:	4a 96       	adiw	r24, 0x1a	; 26
     e7a:	b8 01       	movw	r22, r16
     e7c:	0e 94 50 03 	call	0x6a0	; 0x6a0 <enc28j60PacketSend>
}
     e80:	1f 91       	pop	r17
     e82:	0f 91       	pop	r16
     e84:	ff 90       	pop	r15
     e86:	ef 90       	pop	r14
     e88:	08 95       	ret

00000e8a <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     e8a:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     e8c:	e1 99       	sbic	0x1c, 1	; 28
     e8e:	fe cf       	rjmp	.-4      	; 0xe8c <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     e90:	3f bb       	out	0x1f, r19	; 31
     e92:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     e94:	e0 9a       	sbi	0x1c, 0	; 28
     e96:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     e98:	08 95       	ret

00000e9a <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     e9a:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     e9c:	e1 99       	sbic	0x1c, 1	; 28
     e9e:	fe cf       	rjmp	.-4      	; 0xe9c <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     ea0:	3f bb       	out	0x1f, r19	; 31
     ea2:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
     ea4:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
     ea6:	0f b6       	in	r0, 0x3f	; 63
     ea8:	f8 94       	cli
     eaa:	e2 9a       	sbi	0x1c, 2	; 28
     eac:	e1 9a       	sbi	0x1c, 1	; 28
     eae:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     eb0:	08 95       	ret

00000eb2 <analyse_get_url>:
// takes a string of the form password/commandNumber and analyse it
// return values: -1 invalid password, otherwise command number
//                -2 no command given but password valid
//                -3 valid password, no command and no trailing "/"
int8_t analyse_get_url(char *str)
{
     eb2:	58 2f       	mov	r21, r24
     eb4:	28 2f       	mov	r18, r24
     eb6:	39 2f       	mov	r19, r25
     eb8:	d9 01       	movw	r26, r18
     eba:	05 c0       	rjmp	.+10     	; 0xec6 <analyse_get_url+0x14>
        uint8_t loop=1;
        uint8_t i=0;
        while(loop){
                if(password[i]){
                        if(*str==password[i]){
     ebc:	8e 17       	cp	r24, r30
     ebe:	11 f0       	breq	.+4      	; 0xec4 <analyse_get_url+0x12>
     ec0:	8f ef       	ldi	r24, 0xFF	; 255
     ec2:	08 95       	ret
                                str++;
     ec4:	11 96       	adiw	r26, 0x01	; 1
int8_t analyse_get_url(char *str)
{
        uint8_t loop=1;
        uint8_t i=0;
        while(loop){
                if(password[i]){
     ec6:	ea 2f       	mov	r30, r26
     ec8:	e5 1b       	sub	r30, r21
     eca:	f0 e0       	ldi	r31, 0x00	; 0
     ecc:	e2 56       	subi	r30, 0x62	; 98
     ece:	ff 4f       	sbci	r31, 0xFF	; 255
     ed0:	e0 81       	ld	r30, Z
     ed2:	8c 91       	ld	r24, X
     ed4:	ee 23       	and	r30, r30
     ed6:	91 f7       	brne	.-28     	; 0xebc <analyse_get_url+0xa>
                        // end of password
                        loop=0;
                }
        }
        // is is now one char after the password
        if (*str == '/'){
     ed8:	8f 32       	cpi	r24, 0x2F	; 47
     eda:	11 f0       	breq	.+4      	; 0xee0 <analyse_get_url+0x2e>
     edc:	8d ef       	ldi	r24, 0xFD	; 253
     ede:	08 95       	ret
                str++;
        }else{
                return(-3);
        }
        // check the first char, garbage after this is ignored (including a slash)
        if (*str < 0x3a && *str > 0x2f){
     ee0:	11 96       	adiw	r26, 0x01	; 1
     ee2:	8c 91       	ld	r24, X
     ee4:	80 53       	subi	r24, 0x30	; 48
     ee6:	8a 30       	cpi	r24, 0x0A	; 10
     ee8:	08 f0       	brcs	.+2      	; 0xeec <analyse_get_url+0x3a>
     eea:	8e ef       	ldi	r24, 0xFE	; 254
                // is a ASCII number, return it
                return(*str-0x30);
        }
        return(-2);
}
     eec:	08 95       	ret

00000eee <adc>:
unsigned int adc(unsigned char channel)
{  unsigned int val;
   ADMUX=0x40+channel;
     eee:	80 5c       	subi	r24, 0xC0	; 192
     ef0:	87 b9       	out	0x07, r24	; 7
   ADCSRA=(1<<ADEN);
     ef2:	80 e8       	ldi	r24, 0x80	; 128
     ef4:	86 b9       	out	0x06, r24	; 6
   ADCSRA|=(1<<ADSC);
     ef6:	36 9a       	sbi	0x06, 6	; 6
    ADCSRA|=0x07;
     ef8:	86 b1       	in	r24, 0x06	; 6
     efa:	87 60       	ori	r24, 0x07	; 7
     efc:	86 b9       	out	0x06, r24	; 6
   while(bit_is_clear(ADCSRA,ADIF));
     efe:	34 9b       	sbis	0x06, 4	; 6
     f00:	fe cf       	rjmp	.-4      	; 0xefe <adc+0x10>
   val=ADCW; 
     f02:	24 b1       	in	r18, 0x04	; 4
     f04:	35 b1       	in	r19, 0x05	; 5
   return val;
}
     f06:	c9 01       	movw	r24, r18
     f08:	08 95       	ret

00000f0a <moved_perm>:
        return(fill_tcp_data_p(buf,plen,gStrbuf));
}*/
// answer HTTP/1.0 301 Moved Permanently\r\nLocation: password/\r\n\r\n
// to redirect to the url ending in a slash
uint16_t moved_perm(uint8_t *buf)
{
     f0a:	dc 01       	movw	r26, r24
     f0c:	d6 96       	adiw	r26, 0x36	; 54
     f0e:	20 e0       	ldi	r18, 0x00	; 0
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	03 c0       	rjmp	.+6      	; 0xf1a <moved_perm+0x10>
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
     f14:	4d 93       	st	X+, r20
                pos++;
     f16:	2f 5f       	subi	r18, 0xFF	; 255
     f18:	3f 4f       	sbci	r19, 0xFF	; 255
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
     f1a:	f9 01       	movw	r30, r18
     f1c:	e9 5e       	subi	r30, 0xE9	; 233
     f1e:	fc 4f       	sbci	r31, 0xFC	; 252
     f20:	44 91       	lpm	r20, Z+
     f22:	44 23       	and	r20, r20
     f24:	b9 f7       	brne	.-18     	; 0xf14 <moved_perm+0xa>
     f26:	2a 5c       	subi	r18, 0xCA	; 202
     f28:	3f 4f       	sbci	r19, 0xFF	; 255
     f2a:	dc 01       	movw	r26, r24
     f2c:	a2 0f       	add	r26, r18
     f2e:	b3 1f       	adc	r27, r19
     f30:	26 53       	subi	r18, 0x36	; 54
     f32:	30 40       	sbci	r19, 0x00	; 0
     f34:	ee e9       	ldi	r30, 0x9E	; 158
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	04 c0       	rjmp	.+8      	; 0xf42 <moved_perm+0x38>
{
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
     f3a:	4d 93       	st	X+, r20
                pos++;
     f3c:	2f 5f       	subi	r18, 0xFF	; 255
     f3e:	3f 4f       	sbci	r19, 0xFF	; 255
                s++;
     f40:	31 96       	adiw	r30, 0x01	; 1
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
     f42:	40 81       	ld	r20, Z
     f44:	44 23       	and	r20, r20
     f46:	c9 f7       	brne	.-14     	; 0xf3a <moved_perm+0x30>
     f48:	2a 5c       	subi	r18, 0xCA	; 202
     f4a:	3f 4f       	sbci	r19, 0xFF	; 255
     f4c:	dc 01       	movw	r26, r24
     f4e:	a2 0f       	add	r26, r18
     f50:	b3 1f       	adc	r27, r19
     f52:	26 53       	subi	r18, 0x36	; 54
     f54:	30 40       	sbci	r19, 0x00	; 0
        uint16_t plen;
        plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 301 Moved Permanently\r\nLocation: "));
        plen=fill_tcp_data(buf,plen,password);
        plen=fill_tcp_data_p(buf,plen,PSTR("/\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n"));
     f56:	46 ee       	ldi	r20, 0xE6	; 230
     f58:	52 e0       	ldi	r21, 0x02	; 2
     f5a:	03 c0       	rjmp	.+6      	; 0xf62 <moved_perm+0x58>
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
     f5c:	6d 93       	st	X+, r22
                pos++;
     f5e:	2f 5f       	subi	r18, 0xFF	; 255
     f60:	3f 4f       	sbci	r19, 0xFF	; 255
     f62:	fa 01       	movw	r30, r20
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
     f64:	4f 5f       	subi	r20, 0xFF	; 255
     f66:	5f 4f       	sbci	r21, 0xFF	; 255
     f68:	64 91       	lpm	r22, Z+
     f6a:	66 23       	and	r22, r22
     f6c:	b9 f7       	brne	.-18     	; 0xf5c <moved_perm+0x52>
     f6e:	2a 5c       	subi	r18, 0xCA	; 202
     f70:	3f 4f       	sbci	r19, 0xFF	; 255
     f72:	dc 01       	movw	r26, r24
     f74:	a2 0f       	add	r26, r18
     f76:	b3 1f       	adc	r27, r19
     f78:	26 53       	subi	r18, 0x36	; 54
     f7a:	30 40       	sbci	r19, 0x00	; 0
        plen=fill_tcp_data_p(buf,plen,PSTR("<h1>301 Moved Permanently</h1>\n"));
     f7c:	46 ec       	ldi	r20, 0xC6	; 198
     f7e:	52 e0       	ldi	r21, 0x02	; 2
     f80:	03 c0       	rjmp	.+6      	; 0xf88 <moved_perm+0x7e>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
     f82:	6d 93       	st	X+, r22
                pos++;
     f84:	2f 5f       	subi	r18, 0xFF	; 255
     f86:	3f 4f       	sbci	r19, 0xFF	; 255
     f88:	fa 01       	movw	r30, r20
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
     f8a:	4f 5f       	subi	r20, 0xFF	; 255
     f8c:	5f 4f       	sbci	r21, 0xFF	; 255
     f8e:	64 91       	lpm	r22, Z+
     f90:	66 23       	and	r22, r22
     f92:	b9 f7       	brne	.-18     	; 0xf82 <moved_perm+0x78>
     f94:	2a 5c       	subi	r18, 0xCA	; 202
     f96:	3f 4f       	sbci	r19, 0xFF	; 255
     f98:	dc 01       	movw	r26, r24
     f9a:	a2 0f       	add	r26, r18
     f9c:	b3 1f       	adc	r27, r19
     f9e:	26 53       	subi	r18, 0x36	; 54
     fa0:	30 40       	sbci	r19, 0x00	; 0
        plen=fill_tcp_data_p(buf,plen,PSTR("add a trailing slash to the url\n"));
     fa2:	85 ea       	ldi	r24, 0xA5	; 165
     fa4:	92 e0       	ldi	r25, 0x02	; 2
     fa6:	03 c0       	rjmp	.+6      	; 0xfae <moved_perm+0xa4>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
     fa8:	4d 93       	st	X+, r20
                pos++;
     faa:	2f 5f       	subi	r18, 0xFF	; 255
     fac:	3f 4f       	sbci	r19, 0xFF	; 255
     fae:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
     fb0:	01 96       	adiw	r24, 0x01	; 1
     fb2:	44 91       	lpm	r20, Z+
     fb4:	44 23       	and	r20, r20
     fb6:	c1 f7       	brne	.-16     	; 0xfa8 <moved_perm+0x9e>
        return(plen);
}
     fb8:	c9 01       	movw	r24, r18
     fba:	08 95       	ret

00000fbc <verify_password>:
// the password string (only the first 5 char checked), (only a-z,0-9,_ characters):
static char password[]="123456"; // must not be longer than 9 char

// 
uint8_t verify_password(char *str)
{
     fbc:	bc 01       	movw	r22, r24
        // the first characters of the received string are
        // a simple password/cookie:
        if (strncmp(password,str,5)==0){
     fbe:	8e e9       	ldi	r24, 0x9E	; 158
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	45 e0       	ldi	r20, 0x05	; 5
     fc4:	50 e0       	ldi	r21, 0x00	; 0
     fc6:	0e 94 ac 0a 	call	0x1558	; 0x1558 <strncmp>
     fca:	9c 01       	movw	r18, r24
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	23 2b       	or	r18, r19
     fd0:	09 f4       	brne	.+2      	; 0xfd4 <verify_password+0x18>
     fd2:	81 e0       	ldi	r24, 0x01	; 1
                return(1);
        }
        return(0);
}
     fd4:	08 95       	ret

00000fd6 <print_webpage>:
}


// prepare the webpage by writing the data to the tcp send buffer
uint16_t print_webpage(uint8_t *buf,uint8_t on_off)
{
     fd6:	ff 92       	push	r15
     fd8:	0f 93       	push	r16
     fda:	1f 93       	push	r17
     fdc:	cf 93       	push	r28
     fde:	df 93       	push	r29
     fe0:	8c 01       	movw	r16, r24
     fe2:	f6 2e       	mov	r15, r22
     fe4:	dc 01       	movw	r26, r24
     fe6:	d6 96       	adiw	r26, 0x36	; 54
     fe8:	c0 e0       	ldi	r28, 0x00	; 0
     fea:	d0 e0       	ldi	r29, 0x00	; 0
     fec:	02 c0       	rjmp	.+4      	; 0xff2 <print_webpage+0x1c>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
     fee:	8d 93       	st	X+, r24
                pos++;
     ff0:	21 96       	adiw	r28, 0x01	; 1
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
     ff2:	fe 01       	movw	r30, r28
     ff4:	e7 5a       	subi	r30, 0xA7	; 167
     ff6:	fd 4f       	sbci	r31, 0xFD	; 253
     ff8:	84 91       	lpm	r24, Z+
     ffa:	88 23       	and	r24, r24
     ffc:	c1 f7       	brne	.-16     	; 0xfee <print_webpage+0x18>
     ffe:	e6 96       	adiw	r28, 0x36	; 54
    1000:	d8 01       	movw	r26, r16
    1002:	ac 0f       	add	r26, r28
    1004:	bd 1f       	adc	r27, r29
    1006:	e6 97       	sbiw	r28, 0x36	; 54
        uint16_t plen;
        plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nPragma: no-cache\r\nRefresh: 20\r\n\r\n"));
        plen=fill_tcp_data_p(buf,plen,PSTR("<H1>Solar Irradiance Meter</H1>"));
    1008:	89 e3       	ldi	r24, 0x39	; 57
    100a:	92 e0       	ldi	r25, 0x02	; 2
    100c:	02 c0       	rjmp	.+4      	; 0x1012 <print_webpage+0x3c>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    100e:	2d 93       	st	X+, r18
                pos++;
    1010:	21 96       	adiw	r28, 0x01	; 1
    1012:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    1014:	01 96       	adiw	r24, 0x01	; 1
    1016:	24 91       	lpm	r18, Z+
    1018:	22 23       	and	r18, r18
    101a:	c9 f7       	brne	.-14     	; 0x100e <print_webpage+0x38>
    101c:	e6 96       	adiw	r28, 0x36	; 54
    101e:	d8 01       	movw	r26, r16
    1020:	ac 0f       	add	r26, r28
    1022:	bd 1f       	adc	r27, r29
    1024:	e6 97       	sbiw	r28, 0x36	; 54
        plen=fill_tcp_data_p(buf,plen,PSTR("<center><p><h2>Irradiance is: "));
    1026:	8a e1       	ldi	r24, 0x1A	; 26
    1028:	92 e0       	ldi	r25, 0x02	; 2
    102a:	02 c0       	rjmp	.+4      	; 0x1030 <print_webpage+0x5a>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    102c:	2d 93       	st	X+, r18
                pos++;
    102e:	21 96       	adiw	r28, 0x01	; 1
    1030:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    1032:	01 96       	adiw	r24, 0x01	; 1
    1034:	24 91       	lpm	r18, Z+
    1036:	22 23       	and	r18, r18
    1038:	c9 f7       	brne	.-14     	; 0x102c <print_webpage+0x56>
		itoa(radiance,gStrbuf,10); // convert integer to string
    103a:	80 91 e0 02 	lds	r24, 0x02E0
    103e:	90 91 e1 02 	lds	r25, 0x02E1
    1042:	62 ee       	ldi	r22, 0xE2	; 226
    1044:	72 e0       	ldi	r23, 0x02	; 2
    1046:	4a e0       	ldi	r20, 0x0A	; 10
    1048:	50 e0       	ldi	r21, 0x00	; 0
    104a:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <itoa>
    104e:	e6 96       	adiw	r28, 0x36	; 54
    1050:	d8 01       	movw	r26, r16
    1052:	ac 0f       	add	r26, r28
    1054:	bd 1f       	adc	r27, r29
    1056:	e6 97       	sbiw	r28, 0x36	; 54
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	02 c0       	rjmp	.+4      	; 0x1062 <print_webpage+0x8c>
{
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
    105e:	ed 93       	st	X+, r30
                pos++;
    1060:	21 96       	adiw	r28, 0x01	; 1
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
    1062:	fc 01       	movw	r30, r24
    1064:	ee 51       	subi	r30, 0x1E	; 30
    1066:	fd 4f       	sbci	r31, 0xFD	; 253
    1068:	e0 81       	ld	r30, Z
    106a:	01 96       	adiw	r24, 0x01	; 1
    106c:	ee 23       	and	r30, r30
    106e:	b9 f7       	brne	.-18     	; 0x105e <print_webpage+0x88>
    1070:	e6 96       	adiw	r28, 0x36	; 54
    1072:	d8 01       	movw	r26, r16
    1074:	ac 0f       	add	r26, r28
    1076:	bd 1f       	adc	r27, r29
    1078:	e6 97       	sbiw	r28, 0x36	; 54
		plen=fill_tcp_data(buf,plen,gStrbuf);
		plen=fill_tcp_data_p(buf,plen,PSTR(" Joules</center></h2></p>"));
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	92 e0       	ldi	r25, 0x02	; 2
    107e:	02 c0       	rjmp	.+4      	; 0x1084 <print_webpage+0xae>
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1080:	2d 93       	st	X+, r18
                pos++;
    1082:	21 96       	adiw	r28, 0x01	; 1
    1084:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    1086:	01 96       	adiw	r24, 0x01	; 1
    1088:	24 91       	lpm	r18, Z+
    108a:	22 23       	and	r18, r18
    108c:	c9 f7       	brne	.-14     	; 0x1080 <print_webpage+0xaa>
    108e:	e6 96       	adiw	r28, 0x36	; 54
    1090:	d8 01       	movw	r26, r16
    1092:	ac 0f       	add	r26, r28
    1094:	bd 1f       	adc	r27, r29
    1096:	e6 97       	sbiw	r28, 0x36	; 54
		plen=fill_tcp_data_p(buf,plen,PSTR("<center><p>Output is: "));
    1098:	89 ee       	ldi	r24, 0xE9	; 233
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	02 c0       	rjmp	.+4      	; 0x10a2 <print_webpage+0xcc>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    109e:	2d 93       	st	X+, r18
                pos++;
    10a0:	21 96       	adiw	r28, 0x01	; 1
    10a2:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    10a4:	01 96       	adiw	r24, 0x01	; 1
    10a6:	24 91       	lpm	r18, Z+
    10a8:	22 23       	and	r18, r18
    10aa:	c9 f7       	brne	.-14     	; 0x109e <print_webpage+0xc8>
    10ac:	ce 01       	movw	r24, r28
    10ae:	c6 96       	adiw	r24, 0x36	; 54
        if (on_off){
    10b0:	ff 20       	and	r15, r15
    10b2:	31 f4       	brne	.+12     	; 0x10c0 <print_webpage+0xea>
    10b4:	d8 01       	movw	r26, r16
    10b6:	a8 0f       	add	r26, r24
    10b8:	b9 1f       	adc	r27, r25
                plen=fill_tcp_data_p(buf,plen,PSTR("<font color=\"#00FF00\"> ON</font>"));
        }else{
                plen=fill_tcp_data_p(buf,plen,PSTR("OFF"));
    10ba:	84 ec       	ldi	r24, 0xC4	; 196
    10bc:	91 e0       	ldi	r25, 0x01	; 1
    10be:	17 c0       	rjmp	.+46     	; 0x10ee <print_webpage+0x118>
    10c0:	d8 01       	movw	r26, r16
    10c2:	a8 0f       	add	r26, r24
    10c4:	b9 1f       	adc	r27, r25
		itoa(radiance,gStrbuf,10); // convert integer to string
		plen=fill_tcp_data(buf,plen,gStrbuf);
		plen=fill_tcp_data_p(buf,plen,PSTR(" Joules</center></h2></p>"));
		plen=fill_tcp_data_p(buf,plen,PSTR("<center><p>Output is: "));
        if (on_off){
                plen=fill_tcp_data_p(buf,plen,PSTR("<font color=\"#00FF00\"> ON</font>"));
    10c6:	88 ec       	ldi	r24, 0xC8	; 200
    10c8:	91 e0       	ldi	r25, 0x01	; 1
    10ca:	02 c0       	rjmp	.+4      	; 0x10d0 <print_webpage+0xfa>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    10cc:	2d 93       	st	X+, r18
                pos++;
    10ce:	21 96       	adiw	r28, 0x01	; 1
    10d0:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    10d2:	01 96       	adiw	r24, 0x01	; 1
    10d4:	24 91       	lpm	r18, Z+
    10d6:	22 23       	and	r18, r18
    10d8:	c9 f7       	brne	.-14     	; 0x10cc <print_webpage+0xf6>
    10da:	e6 96       	adiw	r28, 0x36	; 54
    10dc:	d8 01       	movw	r26, r16
    10de:	ac 0f       	add	r26, r28
    10e0:	bd 1f       	adc	r27, r29
    10e2:	e6 97       	sbiw	r28, 0x36	; 54
        }else{
                plen=fill_tcp_data_p(buf,plen,PSTR("OFF"));
        }
        plen=fill_tcp_data_p(buf,plen,PSTR(" <small><a href=\".\">[refresh status]</a></small></p>\n<p><a href=\"."));
    10e4:	81 e8       	ldi	r24, 0x81	; 129
    10e6:	91 e0       	ldi	r25, 0x01	; 1
    10e8:	0a c0       	rjmp	.+20     	; 0x10fe <print_webpage+0x128>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    10ea:	2d 93       	st	X+, r18
                pos++;
    10ec:	21 96       	adiw	r28, 0x01	; 1
    10ee:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    10f0:	01 96       	adiw	r24, 0x01	; 1
    10f2:	24 91       	lpm	r18, Z+
    10f4:	22 23       	and	r18, r18
    10f6:	c9 f7       	brne	.-14     	; 0x10ea <print_webpage+0x114>
    10f8:	f0 cf       	rjmp	.-32     	; 0x10da <print_webpage+0x104>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    10fa:	2d 93       	st	X+, r18
                pos++;
    10fc:	21 96       	adiw	r28, 0x01	; 1
    10fe:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    1100:	01 96       	adiw	r24, 0x01	; 1
    1102:	24 91       	lpm	r18, Z+
    1104:	22 23       	and	r18, r18
    1106:	c9 f7       	brne	.-14     	; 0x10fa <print_webpage+0x124>
    1108:	ce 01       	movw	r24, r28
    110a:	c6 96       	adiw	r24, 0x36	; 54
        if (on_off){
    110c:	ff 20       	and	r15, r15
    110e:	31 f4       	brne	.+12     	; 0x111c <print_webpage+0x146>
    1110:	d8 01       	movw	r26, r16
    1112:	a8 0f       	add	r26, r24
    1114:	b9 1f       	adc	r27, r25
                plen=fill_tcp_data_p(buf,plen,PSTR("/0\">Switch off</a><p>"));
        }else{
                plen=fill_tcp_data_p(buf,plen,PSTR("/1\">Switch on</a><p>"));
    1116:	86 e5       	ldi	r24, 0x56	; 86
    1118:	91 e0       	ldi	r25, 0x01	; 1
    111a:	17 c0       	rjmp	.+46     	; 0x114a <print_webpage+0x174>
    111c:	d8 01       	movw	r26, r16
    111e:	a8 0f       	add	r26, r24
    1120:	b9 1f       	adc	r27, r25
        }else{
                plen=fill_tcp_data_p(buf,plen,PSTR("OFF"));
        }
        plen=fill_tcp_data_p(buf,plen,PSTR(" <small><a href=\".\">[refresh status]</a></small></p>\n<p><a href=\"."));
        if (on_off){
                plen=fill_tcp_data_p(buf,plen,PSTR("/0\">Switch off</a><p>"));
    1122:	8b e6       	ldi	r24, 0x6B	; 107
    1124:	91 e0       	ldi	r25, 0x01	; 1
    1126:	02 c0       	rjmp	.+4      	; 0x112c <print_webpage+0x156>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1128:	2d 93       	st	X+, r18
                pos++;
    112a:	21 96       	adiw	r28, 0x01	; 1
    112c:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    112e:	01 96       	adiw	r24, 0x01	; 1
    1130:	24 91       	lpm	r18, Z+
    1132:	22 23       	and	r18, r18
    1134:	c9 f7       	brne	.-14     	; 0x1128 <print_webpage+0x152>
    1136:	e6 96       	adiw	r28, 0x36	; 54
    1138:	d8 01       	movw	r26, r16
    113a:	ac 0f       	add	r26, r28
    113c:	bd 1f       	adc	r27, r29
    113e:	e6 97       	sbiw	r28, 0x36	; 54
        }else{
                plen=fill_tcp_data_p(buf,plen,PSTR("/1\">Switch on</a><p>"));
        }
        plen=fill_tcp_data_p(buf,plen,PSTR("</center><hr><br>version 1.0,\n"));
    1140:	87 e3       	ldi	r24, 0x37	; 55
    1142:	91 e0       	ldi	r25, 0x01	; 1
    1144:	0a c0       	rjmp	.+20     	; 0x115a <print_webpage+0x184>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1146:	2d 93       	st	X+, r18
                pos++;
    1148:	21 96       	adiw	r28, 0x01	; 1
    114a:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    114c:	01 96       	adiw	r24, 0x01	; 1
    114e:	24 91       	lpm	r18, Z+
    1150:	22 23       	and	r18, r18
    1152:	c9 f7       	brne	.-14     	; 0x1146 <print_webpage+0x170>
    1154:	f0 cf       	rjmp	.-32     	; 0x1136 <print_webpage+0x160>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1156:	2d 93       	st	X+, r18
                pos++;
    1158:	21 96       	adiw	r28, 0x01	; 1
    115a:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    115c:	01 96       	adiw	r24, 0x01	; 1
    115e:	24 91       	lpm	r18, Z+
    1160:	22 23       	and	r18, r18
    1162:	c9 f7       	brne	.-14     	; 0x1156 <print_webpage+0x180>
        return(plen);
}
    1164:	ce 01       	movw	r24, r28
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	1f 91       	pop	r17
    116c:	0f 91       	pop	r16
    116e:	ff 90       	pop	r15
    1170:	08 95       	ret

00001172 <main>:


int main(void){
    1172:	9f 92       	push	r9
    1174:	af 92       	push	r10
    1176:	bf 92       	push	r11
    1178:	cf 92       	push	r12
    117a:	df 92       	push	r13
    117c:	ef 92       	push	r14
    117e:	ff 92       	push	r15
    1180:	0f 93       	push	r16
    1182:	1f 93       	push	r17
    1184:	df 93       	push	r29
    1186:	cf 93       	push	r28
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	6e 97       	sbiw	r28, 0x1e	; 30
    118e:	0f b6       	in	r0, 0x3f	; 63
    1190:	f8 94       	cli
    1192:	de bf       	out	0x3e, r29	; 62
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	cd bf       	out	0x3d, r28	; 61
    1198:	12 e3       	ldi	r17, 0x32	; 50
    119a:	81 2f       	mov	r24, r17
    119c:	8a 95       	dec	r24
    119e:	f1 f7       	brne	.-4      	; 0x119c <main+0x2a>
//        CLKPR=(1<<CLKPCE); // change enable
//        CLKPR=0; // "no pre-scaler"
        _delay_loop_1(50); // 12ms

        /* enable PD2/INT0, as input */
        DDRD&= ~(1<<DDD2);
    11a0:	8a 98       	cbi	0x11, 2	; 17

        /*initialize enc28j60*/
        enc28j60Init(mymac);
    11a2:	84 e9       	ldi	r24, 0x94	; 148
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	0e 94 8b 02 	call	0x516	; 0x516 <enc28j60Init>
        enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    11aa:	82 e0       	ldi	r24, 0x02	; 2
    11ac:	0e 94 85 02 	call	0x50a	; 0x50a <enc28j60clkout>
    11b0:	1a 95       	dec	r17
    11b2:	f1 f7       	brne	.-4      	; 0x11b0 <main+0x3e>
        _delay_loop_1(50); // 12ms
        
        // LED
        /* enable PB1, LED as output */
        DDRB|= (1<<DDB1);
    11b4:	b9 9a       	sbi	0x17, 1	; 23

        /* set output to Vcc, LED off */
        PORTB|= (1<<PORTB1);
    11b6:	c1 9a       	sbi	0x18, 1	; 24

        // the transistor on PD7
        DDRD=0x80;DDRA=0xF0;
    11b8:	80 e8       	ldi	r24, 0x80	; 128
    11ba:	81 bb       	out	0x11, r24	; 17
    11bc:	80 ef       	ldi	r24, 0xF0	; 240
    11be:	8a bb       	out	0x1a, r24	; 26
       // PORTD &= ~(1<<PORTD7);// transistor off
        DDRC=0xFF;
    11c0:	8f ef       	ldi	r24, 0xFF	; 255
    11c2:	84 bb       	out	0x14, r24	; 20
		PORTD=0xFF;
    11c4:	82 bb       	out	0x12, r24	; 18
		PORTC = 0x00;// transistor off
    11c6:	15 ba       	out	0x15, r1	; 21
        if((PIND&0x01)==0)
    11c8:	80 99       	sbic	0x10, 0	; 16
    11ca:	10 c0       	rjmp	.+32     	; 0x11ec <main+0x7a>
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
    11cc:	80 e0       	ldi	r24, 0x00	; 0
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	6b e4       	ldi	r22, 0x4B	; 75
    11d2:	76 e0       	ldi	r23, 0x06	; 6
    11d4:	4d e4       	ldi	r20, 0x4D	; 77
    11d6:	57 e0       	ldi	r21, 0x07	; 7
    11d8:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <__eewr_word>
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    11dc:	82 e0       	ldi	r24, 0x02	; 2
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	68 e7       	ldi	r22, 0x78	; 120
    11e2:	70 e0       	ldi	r23, 0x00	; 0
    11e4:	4d e4       	ldi	r20, 0x4D	; 77
    11e6:	57 e0       	ldi	r21, 0x07	; 7
    11e8:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <__eewr_word>
    11ec:	80 e0       	ldi	r24, 0x00	; 0
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	65 e4       	ldi	r22, 0x45	; 69
    11f2:	77 e0       	ldi	r23, 0x07	; 7
    11f4:	0e 94 ba 0a 	call	0x1574	; 0x1574 <__eerd_word>
    11f8:	7c 01       	movw	r14, r24
        {
        eeprom_write_word(&eid,1611);
        eeprom_write_word(&valt,120);
        }   
        rch=eeprom_read_word(&eid);
lch=eeprom_read_word(&valt);
    11fa:	82 e0       	ldi	r24, 0x02	; 2
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	65 e4       	ldi	r22, 0x45	; 69
    1200:	77 e0       	ldi	r23, 0x07	; 7
    1202:	0e 94 ba 0a 	call	0x1574	; 0x1574 <__eerd_word>
    1206:	8c 01       	movw	r16, r24
if(lch!=0)
    1208:	00 97       	sbiw	r24, 0x00	; 0
    120a:	49 f0       	breq	.+18     	; 0x121e <main+0xac>
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
    120c:	bc 01       	movw	r22, r24
    120e:	61 50       	subi	r22, 0x01	; 1
    1210:	70 40       	sbci	r23, 0x00	; 0
    1212:	82 e0       	ldi	r24, 0x02	; 2
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	4d e4       	ldi	r20, 0x4D	; 77
    1218:	57 e0       	ldi	r21, 0x07	; 7
    121a:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <__eewr_word>
eeprom_write_word(&valt,lch-1);
 
if(rch!=1611 ||lch==0)
    121e:	8b e4       	ldi	r24, 0x4B	; 75
    1220:	e8 16       	cp	r14, r24
    1222:	86 e0       	ldi	r24, 0x06	; 6
    1224:	f8 06       	cpc	r15, r24
    1226:	11 f4       	brne	.+4      	; 0x122c <main+0xba>
    1228:	01 2b       	or	r16, r17
    122a:	09 f4       	brne	.+2      	; 0x122e <main+0xbc>
    122c:	ff cf       	rjmp	.-2      	; 0x122c <main+0xba>
        /* Magjack leds configuration, see enc28j60 datasheet, page 11 */
        // LEDB=yellow LEDA=green
        //
        // 0x476 is PHLCON LEDA=links status, LEDB=receive/transmit
        // enc28j60PhyWrite(PHLCON,0b0000 0100 0111 01 10);
        enc28j60PhyWrite(PHLCON,0x476);
    122e:	84 e1       	ldi	r24, 0x14	; 20
    1230:	66 e7       	ldi	r22, 0x76	; 118
    1232:	74 e0       	ldi	r23, 0x04	; 4
    1234:	0e 94 67 02 	call	0x4ce	; 0x4ce <enc28j60PhyWrite>
    1238:	82 e3       	ldi	r24, 0x32	; 50
    123a:	8a 95       	dec	r24
    123c:	f1 f7       	brne	.-4      	; 0x123a <main+0xc8>
        _delay_loop_1(50); // 12ms
        
        /* set output to GND, red LED on */
        PORTB &= ~(1<<PORTB1);
    123e:	c1 98       	cbi	0x18, 1	; 24
}

// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint8_t wwwp){
        uint8_t i=0;
        wwwport=wwwp;
    1240:	80 e5       	ldi	r24, 0x50	; 80
    1242:	80 93 a5 00 	sts	0x00A5, r24
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	30 e0       	ldi	r19, 0x00	; 0
        while(i<4){
                ipaddr[i]=myip[i];
    124a:	f9 01       	movw	r30, r18
    124c:	eb 54       	subi	r30, 0x4B	; 75
    124e:	ff 4f       	sbci	r31, 0xFF	; 255
    1250:	d9 01       	movw	r26, r18
    1252:	a6 56       	subi	r26, 0x66	; 102
    1254:	bf 4f       	sbci	r27, 0xFF	; 255
    1256:	8c 91       	ld	r24, X
    1258:	80 83       	st	Z, r24
    125a:	2f 5f       	subi	r18, 0xFF	; 255
    125c:	3f 4f       	sbci	r19, 0xFF	; 255

// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint8_t wwwp){
        uint8_t i=0;
        wwwport=wwwp;
        while(i<4){
    125e:	24 30       	cpi	r18, 0x04	; 4
    1260:	31 05       	cpc	r19, r1
    1262:	99 f7       	brne	.-26     	; 0x124a <main+0xd8>
    1264:	20 e0       	ldi	r18, 0x00	; 0
    1266:	30 e0       	ldi	r19, 0x00	; 0
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
                macaddr[i]=mymac[i];
    1268:	f9 01       	movw	r30, r18
    126a:	e1 55       	subi	r30, 0x51	; 81
    126c:	ff 4f       	sbci	r31, 0xFF	; 255
    126e:	d9 01       	movw	r26, r18
    1270:	ac 56       	subi	r26, 0x6C	; 108
    1272:	bf 4f       	sbci	r27, 0xFF	; 255
    1274:	8c 91       	ld	r24, X
    1276:	80 83       	st	Z, r24
    1278:	2f 5f       	subi	r18, 0xFF	; 255
    127a:	3f 4f       	sbci	r19, 0xFF	; 255
        while(i<4){
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
    127c:	26 30       	cpi	r18, 0x06	; 6
    127e:	31 05       	cpc	r19, r1
    1280:	99 f7       	brne	.-26     	; 0x1268 <main+0xf6>
    1282:	bb 24       	eor	r11, r11
    1284:	b3 94       	inc	r11
                                strcpy(str,"e=no_such_cmd");
                                goto ANSWER;
                        }
                        strcpy(str,"e=invalid_pw");
ANSWER:
                        make_udp_reply_from_request(buf,str,strlen(str),MYUDPPORT);
    1286:	6e 01       	movw	r12, r28
    1288:	08 94       	sec
    128a:	c1 1c       	adc	r12, r1
    128c:	d1 1c       	adc	r13, r1
        }
        return(-2);
}
unsigned int adc(unsigned char channel)
{  unsigned int val;
   ADMUX=0x40+channel;
    128e:	70 e4       	ldi	r23, 0x40	; 64
    1290:	a7 2e       	mov	r10, r23
   ADCSRA=(1<<ADEN);
    1292:	60 e8       	ldi	r22, 0x80	; 128
    1294:	96 2e       	mov	r9, r22
        //init the ethernet/ip layer:
        init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

        while(1){
                // get the next new packet:
                plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    1296:	86 e2       	ldi	r24, 0x26	; 38
    1298:	92 e0       	ldi	r25, 0x02	; 2
    129a:	69 eb       	ldi	r22, 0xB9	; 185
    129c:	70 e0       	ldi	r23, 0x00	; 0
    129e:	0e 94 c2 03 	call	0x784	; 0x784 <enc28j60PacketReceive>
    12a2:	8c 01       	movw	r16, r24

                /*plen will ne unequal to zero if there is a valid 
                 * packet (without crc error) */
                if(plen==0){
    12a4:	00 97       	sbiw	r24, 0x00	; 0
    12a6:	b9 f3       	breq	.-18     	; 0x1296 <main+0x124>
                }
                        
                // arp is broadcast if unknown but a host may also
                // verify the mac address by sending it to 
                // a unicast address.
                if(eth_type_is_arp_and_my_ip(buf,plen)){
    12a8:	89 eb       	ldi	r24, 0xB9	; 185
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	b8 01       	movw	r22, r16
    12ae:	0e 94 fd 04 	call	0x9fa	; 0x9fa <eth_type_is_arp_and_my_ip>
    12b2:	88 23       	and	r24, r24
    12b4:	29 f0       	breq	.+10     	; 0x12c0 <main+0x14e>
                        make_arp_answer_from_request(buf);
    12b6:	89 eb       	ldi	r24, 0xB9	; 185
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	0e 94 ac 05 	call	0xb58	; 0xb58 <make_arp_answer_from_request>
    12be:	eb cf       	rjmp	.-42     	; 0x1296 <main+0x124>
                        continue;
                }

                // check if ip packets are for us:
                if(eth_type_is_ip_and_my_ip(buf,plen)==0){
    12c0:	89 eb       	ldi	r24, 0xB9	; 185
    12c2:	90 e0       	ldi	r25, 0x00	; 0
    12c4:	b8 01       	movw	r22, r16
    12c6:	0e 94 19 05 	call	0xa32	; 0xa32 <eth_type_is_ip_and_my_ip>
    12ca:	88 23       	and	r24, r24
    12cc:	21 f3       	breq	.-56     	; 0x1296 <main+0x124>
                        continue;
                }
                // led----------
                if (i){
    12ce:	bb 20       	and	r11, r11
    12d0:	19 f0       	breq	.+6      	; 0x12d8 <main+0x166>
                        /* set output to Vcc, LED off */
                        PORTB|= (1<<PORTB1);
    12d2:	c1 9a       	sbi	0x18, 1	; 24
    12d4:	bb 24       	eor	r11, r11
    12d6:	03 c0       	rjmp	.+6      	; 0x12de <main+0x16c>
                        i=0;
                }else{
                        /* set output to GND, LED on */
                        PORTB &= ~(1<<PORTB1);
    12d8:	c1 98       	cbi	0x18, 1	; 24
    12da:	bb 24       	eor	r11, r11
    12dc:	b3 94       	inc	r11
                        i=1;
                }
                
                if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V){
    12de:	80 91 d0 00 	lds	r24, 0x00D0
    12e2:	81 30       	cpi	r24, 0x01	; 1
    12e4:	51 f4       	brne	.+20     	; 0x12fa <main+0x188>
    12e6:	80 91 db 00 	lds	r24, 0x00DB
    12ea:	88 30       	cpi	r24, 0x08	; 8
    12ec:	a1 f6       	brne	.-88     	; 0x1296 <main+0x124>
                        // a ping packet, let's send pong
                        make_echo_reply_from_request(buf,plen);
    12ee:	89 eb       	ldi	r24, 0xB9	; 185
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	b8 01       	movw	r22, r16
    12f4:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <make_echo_reply_from_request>
    12f8:	ce cf       	rjmp	.-100    	; 0x1296 <main+0x124>
                        continue;
                }
                // tcp port www start, compare only the lower byte
                if (buf[IP_PROTO_P]==IP_PROTO_TCP_V&&buf[TCP_DST_PORT_H_P]==0&&buf[TCP_DST_PORT_L_P]==MYWWWPORT){
    12fa:	86 30       	cpi	r24, 0x06	; 6
    12fc:	09 f0       	breq	.+2      	; 0x1300 <main+0x18e>
    12fe:	bd c0       	rjmp	.+378    	; 0x147a <main+0x308>
    1300:	80 91 dd 00 	lds	r24, 0x00DD
    1304:	88 23       	and	r24, r24
    1306:	39 f6       	brne	.-114    	; 0x1296 <main+0x124>
    1308:	80 91 de 00 	lds	r24, 0x00DE
    130c:	80 35       	cpi	r24, 0x50	; 80
    130e:	19 f6       	brne	.-122    	; 0x1296 <main+0x124>
                        if (buf[TCP_FLAGS_P] & TCP_FLAGS_SYN_V){
    1310:	80 91 e8 00 	lds	r24, 0x00E8
    1314:	81 ff       	sbrs	r24, 1
    1316:	05 c0       	rjmp	.+10     	; 0x1322 <main+0x1b0>
                                make_tcp_synack_from_syn(buf);
    1318:	89 eb       	ldi	r24, 0xB9	; 185
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <make_tcp_synack_from_syn>
    1320:	ba cf       	rjmp	.-140    	; 0x1296 <main+0x124>
                                // make_tcp_synack_from_syn does already send the syn,ack
                                continue;
                        }
                        if (buf[TCP_FLAGS_P] & TCP_FLAGS_ACK_V){
    1322:	84 ff       	sbrs	r24, 4
    1324:	b8 cf       	rjmp	.-144    	; 0x1296 <main+0x124>
                                init_len_info(buf); // init some data structures
    1326:	89 eb       	ldi	r24, 0xB9	; 185
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	0e 94 9b 06 	call	0xd36	; 0xd36 <init_len_info>
// get a pointer to the start of tcp data in buf
// Returns 0 if there is no data
// You must call init_len_info once before calling this function
uint16_t get_tcp_data_pointer(void)
{
        if (info_data_len){
    132e:	80 91 a8 00 	lds	r24, 0x00A8
    1332:	90 91 a9 00 	lds	r25, 0x00A9
    1336:	89 2b       	or	r24, r25
    1338:	61 f0       	breq	.+24     	; 0x1352 <main+0x1e0>
                return((uint16_t)TCP_SRC_PORT_H_P+info_hdr_len);
    133a:	00 91 aa 00 	lds	r16, 0x00AA
    133e:	10 91 ab 00 	lds	r17, 0x00AB
    1342:	52 e2       	ldi	r21, 0x22	; 34
    1344:	e5 2e       	mov	r14, r21
    1346:	f1 2c       	mov	r15, r1
    1348:	e0 0e       	add	r14, r16
    134a:	f1 1e       	adc	r15, r17
                                // we can possibly have no data, just ack:
                                dat_p=get_tcp_data_pointer();
                                if (dat_p==0){
    134c:	e1 14       	cp	r14, r1
    134e:	f1 04       	cpc	r15, r1
    1350:	49 f4       	brne	.+18     	; 0x1364 <main+0x1f2>
                                        if (buf[TCP_FLAGS_P] & TCP_FLAGS_FIN_V){
    1352:	80 91 e8 00 	lds	r24, 0x00E8
    1356:	80 ff       	sbrs	r24, 0
    1358:	9e cf       	rjmp	.-196    	; 0x1296 <main+0x124>
                                                // finack, answer with ack
                                                make_tcp_ack_from_any(buf);
    135a:	89 eb       	ldi	r24, 0xB9	; 185
    135c:	90 e0       	ldi	r25, 0x00	; 0
    135e:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <make_tcp_ack_from_any>
    1362:	99 cf       	rjmp	.-206    	; 0x1296 <main+0x124>
                                        }
                                        // just an ack with no data, wait for next packet
                                        continue;
                                }
                                if (strncmp("GET ",(char *)&(buf[dat_p]),4)!=0){
    1364:	b7 01       	movw	r22, r14
    1366:	67 54       	subi	r22, 0x47	; 71
    1368:	7f 4f       	sbci	r23, 0xFF	; 255
    136a:	80 e6       	ldi	r24, 0x60	; 96
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	44 e0       	ldi	r20, 0x04	; 4
    1370:	50 e0       	ldi	r21, 0x00	; 0
    1372:	0e 94 ac 0a 	call	0x1558	; 0x1558 <strncmp>
    1376:	00 97       	sbiw	r24, 0x00	; 0
    1378:	81 f0       	breq	.+32     	; 0x139a <main+0x228>
    137a:	00 e0       	ldi	r16, 0x00	; 0
    137c:	10 e0       	ldi	r17, 0x00	; 0
    137e:	06 c0       	rjmp	.+12     	; 0x138c <main+0x21a>
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1380:	f8 01       	movw	r30, r16
    1382:	e7 54       	subi	r30, 0x47	; 71
    1384:	ff 4f       	sbci	r31, 0xFF	; 255
    1386:	86 ab       	std	Z+54, r24	; 0x36
                pos++;
    1388:	0f 5f       	subi	r16, 0xFF	; 255
    138a:	1f 4f       	sbci	r17, 0xFF	; 255
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    138c:	f8 01       	movw	r30, r16
    138e:	e5 50       	subi	r30, 0x05	; 5
    1390:	ff 4f       	sbci	r31, 0xFF	; 255
    1392:	84 91       	lpm	r24, Z+
    1394:	88 23       	and	r24, r24
    1396:	a1 f7       	brne	.-24     	; 0x1380 <main+0x20e>
    1398:	66 c0       	rjmp	.+204    	; 0x1466 <main+0x2f4>
                                        // for possible status codes see:
                                        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
                                        plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n<h1>200 OK</h1>"));
                                        goto SENDTCP;
                                }
                                if (strncmp("/ ",(char *)&(buf[dat_p+4]),2)==0){
    139a:	01 52       	subi	r16, 0x21	; 33
    139c:	1f 4f       	sbci	r17, 0xFF	; 255
    139e:	85 e6       	ldi	r24, 0x65	; 101
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	b8 01       	movw	r22, r16
    13a4:	42 e0       	ldi	r20, 0x02	; 2
    13a6:	50 e0       	ldi	r21, 0x00	; 0
    13a8:	0e 94 ac 0a 	call	0x1558	; 0x1558 <strncmp>
    13ac:	00 97       	sbiw	r24, 0x00	; 0
    13ae:	f1 f4       	brne	.+60     	; 0x13ec <main+0x27a>
    13b0:	00 e0       	ldi	r16, 0x00	; 0
    13b2:	10 e0       	ldi	r17, 0x00	; 0
    13b4:	06 c0       	rjmp	.+12     	; 0x13c2 <main+0x250>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    13b6:	f8 01       	movw	r30, r16
    13b8:	e7 54       	subi	r30, 0x47	; 71
    13ba:	ff 4f       	sbci	r31, 0xFF	; 255
    13bc:	86 ab       	std	Z+54, r24	; 0x36
                pos++;
    13be:	0f 5f       	subi	r16, 0xFF	; 255
    13c0:	1f 4f       	sbci	r17, 0xFF	; 255
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    13c2:	f8 01       	movw	r30, r16
    13c4:	e2 53       	subi	r30, 0x32	; 50
    13c6:	ff 4f       	sbci	r31, 0xFF	; 255
    13c8:	84 91       	lpm	r24, Z+
    13ca:	88 23       	and	r24, r24
    13cc:	a1 f7       	brne	.-24     	; 0x13b6 <main+0x244>
    13ce:	d8 01       	movw	r26, r16
    13d0:	a1 51       	subi	r26, 0x11	; 17
    13d2:	bf 4f       	sbci	r27, 0xFF	; 255
                                        plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n"));
                                        plen=fill_tcp_data_p(buf,plen,PSTR("<p>Usage: http://host_or_ip/password</p>\n"));
    13d4:	84 ea       	ldi	r24, 0xA4	; 164
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	03 c0       	rjmp	.+6      	; 0x13e0 <main+0x26e>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    13da:	2d 93       	st	X+, r18
                pos++;
    13dc:	0f 5f       	subi	r16, 0xFF	; 255
    13de:	1f 4f       	sbci	r17, 0xFF	; 255
    13e0:	fc 01       	movw	r30, r24
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    13e2:	01 96       	adiw	r24, 0x01	; 1
    13e4:	24 91       	lpm	r18, Z+
    13e6:	22 23       	and	r18, r18
    13e8:	c1 f7       	brne	.-16     	; 0x13da <main+0x268>
    13ea:	3d c0       	rjmp	.+122    	; 0x1466 <main+0x2f4>
                                        goto SENDTCP;
                                }
                                cmd=analyse_get_url((char *)&(buf[dat_p+5]));
    13ec:	c7 01       	movw	r24, r14
    13ee:	82 54       	subi	r24, 0x42	; 66
    13f0:	9f 4f       	sbci	r25, 0xFF	; 255
    13f2:	0e 94 59 07 	call	0xeb2	; 0xeb2 <analyse_get_url>
                                // for possible status codes see:
                                // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
                                if (cmd==-1){
    13f6:	8f 3f       	cpi	r24, 0xFF	; 255
    13f8:	81 f4       	brne	.+32     	; 0x141a <main+0x2a8>
    13fa:	00 e0       	ldi	r16, 0x00	; 0
    13fc:	10 e0       	ldi	r17, 0x00	; 0
    13fe:	06 c0       	rjmp	.+12     	; 0x140c <main+0x29a>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1400:	f8 01       	movw	r30, r16
    1402:	e7 54       	subi	r30, 0x47	; 71
    1404:	ff 4f       	sbci	r31, 0xFF	; 255
    1406:	86 ab       	std	Z+54, r24	; 0x36
                pos++;
    1408:	0f 5f       	subi	r16, 0xFF	; 255
    140a:	1f 4f       	sbci	r17, 0xFF	; 255
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    140c:	f8 01       	movw	r30, r16
    140e:	ec 5a       	subi	r30, 0xAC	; 172
    1410:	ff 4f       	sbci	r31, 0xFF	; 255
    1412:	84 91       	lpm	r24, Z+
    1414:	88 23       	and	r24, r24
    1416:	a1 f7       	brne	.-24     	; 0x1400 <main+0x28e>
    1418:	26 c0       	rjmp	.+76     	; 0x1466 <main+0x2f4>
                                        plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 401 Unauthorized\r\nContent-Type: text/html\r\n\r\n<h1>401 Unauthorized</h1>"));
                                        goto SENDTCP;
                                }
                                if (cmd==1){
    141a:	81 30       	cpi	r24, 0x01	; 1
    141c:	19 f4       	brne	.+6      	; 0x1424 <main+0x2b2>
                                       // PORTD|= (1<<PORTD7);// transistor on
										PORTC|= (1<<0);// transistor on
    141e:	a8 9a       	sbi	0x15, 0	; 21
                                       sbi(PORTA,4);
    1420:	dc 9a       	sbi	0x1b, 4	; 27
    1422:	0c c0       	rjmp	.+24     	; 0x143c <main+0x2ca>
								}
                                if (cmd==0){
    1424:	88 23       	and	r24, r24
    1426:	19 f4       	brne	.+6      	; 0x142e <main+0x2bc>
                                       // PORTD &= ~(1<<PORTD7);// transistor off
                                        PORTC &= ~(1<<0);// transistor off
    1428:	a8 98       	cbi	0x15, 0	; 21
										cbi(PORTA,4);
    142a:	dc 98       	cbi	0x1b, 4	; 27
    142c:	07 c0       	rjmp	.+14     	; 0x143c <main+0x2ca>
                                }
                                if (cmd==-3){
    142e:	8d 3f       	cpi	r24, 0xFD	; 253
    1430:	29 f4       	brne	.+10     	; 0x143c <main+0x2ca>
                                        // redirect to add a trailing slash
                                        plen=moved_perm(buf);
    1432:	89 eb       	ldi	r24, 0xB9	; 185
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	0e 94 85 07 	call	0xf0a	; 0xf0a <moved_perm>
    143a:	14 c0       	rjmp	.+40     	; 0x1464 <main+0x2f2>
        }
        return(-2);
}
unsigned int adc(unsigned char channel)
{  unsigned int val;
   ADMUX=0x40+channel;
    143c:	a7 b8       	out	0x07, r10	; 7
   ADCSRA=(1<<ADEN);
    143e:	96 b8       	out	0x06, r9	; 6
   ADCSRA|=(1<<ADSC);
    1440:	36 9a       	sbi	0x06, 6	; 6
    ADCSRA|=0x07;
    1442:	86 b1       	in	r24, 0x06	; 6
    1444:	87 60       	ori	r24, 0x07	; 7
    1446:	86 b9       	out	0x06, r24	; 6
   while(bit_is_clear(ADCSRA,ADIF));
    1448:	34 9b       	sbis	0x06, 4	; 6
    144a:	fe cf       	rjmp	.-4      	; 0x1448 <main+0x2d6>
   val=ADCW; 
    144c:	84 b1       	in	r24, 0x04	; 4
    144e:	95 b1       	in	r25, 0x05	; 5
                                if (cmd==-3){
                                        // redirect to add a trailing slash
                                        plen=moved_perm(buf);
                                        goto SENDTCP;
                                }
								radiance=adc(0);
    1450:	90 93 e1 02 	sts	0x02E1, r25
    1454:	80 93 e0 02 	sts	0x02E0, r24
                                // if (cmd==-2) or any other value
                                // just display the status:
                                plen=print_webpage(buf,(PORTC & (1<<PORTC0)));
    1458:	65 b3       	in	r22, 0x15	; 21
    145a:	61 70       	andi	r22, 0x01	; 1
    145c:	89 eb       	ldi	r24, 0xB9	; 185
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <print_webpage>
    1464:	8c 01       	movw	r16, r24
                                //
SENDTCP:
                                make_tcp_ack_from_any(buf); // send ack for http get
    1466:	89 eb       	ldi	r24, 0xB9	; 185
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <make_tcp_ack_from_any>
                                make_tcp_ack_with_data(buf,plen); // send data
    146e:	89 eb       	ldi	r24, 0xB9	; 185
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	b8 01       	movw	r22, r16
    1474:	0e 94 1b 07 	call	0xe36	; 0xe36 <make_tcp_ack_with_data>
    1478:	0e cf       	rjmp	.-484    	; 0x1296 <main+0x124>

                }
                // tcp port www end
                //
                // udp start, we listen on udp port 1200=0x4B0
                if (buf[IP_PROTO_P]==IP_PROTO_UDP_V&&buf[UDP_DST_PORT_H_P]==4&&buf[UDP_DST_PORT_L_P]==0xb0){
    147a:	81 31       	cpi	r24, 0x11	; 17
    147c:	09 f0       	breq	.+2      	; 0x1480 <main+0x30e>
    147e:	0b cf       	rjmp	.-490    	; 0x1296 <main+0x124>
    1480:	80 91 dd 00 	lds	r24, 0x00DD
    1484:	84 30       	cpi	r24, 0x04	; 4
    1486:	09 f0       	breq	.+2      	; 0x148a <main+0x318>
    1488:	06 cf       	rjmp	.-500    	; 0x1296 <main+0x124>
    148a:	80 91 de 00 	lds	r24, 0x00DE
    148e:	80 3b       	cpi	r24, 0xB0	; 176
    1490:	09 f0       	breq	.+2      	; 0x1494 <main+0x322>
    1492:	01 cf       	rjmp	.-510    	; 0x1296 <main+0x124>
                        payloadlen=buf[UDP_LEN_L_P]-UDP_HEADER_LEN;
    1494:	10 91 e0 00 	lds	r17, 0x00E0
    1498:	18 50       	subi	r17, 0x08	; 8
                        // you must sent a string starting with v
                        // e.g udpcom version 10.0.0.24
                        if (verify_password((char *)&(buf[UDP_DATA_P]))){
    149a:	83 ee       	ldi	r24, 0xE3	; 227
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	0e 94 de 07 	call	0xfbc	; 0xfbc <verify_password>
    14a2:	88 23       	and	r24, r24
    14a4:	59 f4       	brne	.+22     	; 0x14bc <main+0x34a>
    14a6:	3c c0       	rjmp	.+120    	; 0x1520 <main+0x3ae>
                                // find the first comma which indicates 
                                // the start of a command:
                                cmd_pos=0;
                                while(cmd_pos<payloadlen){
                                        cmd_pos++;
    14a8:	9f 5f       	subi	r25, 0xFF	; 255
                                        if (buf[UDP_DATA_P+cmd_pos]==','){
    14aa:	e9 2f       	mov	r30, r25
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	e7 54       	subi	r30, 0x47	; 71
    14b0:	ff 4f       	sbci	r31, 0xFF	; 255
    14b2:	82 a5       	ldd	r24, Z+42	; 0x2a
    14b4:	8c 32       	cpi	r24, 0x2C	; 44
    14b6:	19 f4       	brne	.+6      	; 0x14be <main+0x34c>
                                                cmd_pos++; // put on start of cmd
    14b8:	9f 5f       	subi	r25, 0xFF	; 255
    14ba:	03 c0       	rjmp	.+6      	; 0x14c2 <main+0x350>
                                                break;
    14bc:	90 e0       	ldi	r25, 0x00	; 0
                        // e.g udpcom version 10.0.0.24
                        if (verify_password((char *)&(buf[UDP_DATA_P]))){
                                // find the first comma which indicates 
                                // the start of a command:
                                cmd_pos=0;
                                while(cmd_pos<payloadlen){
    14be:	91 17       	cp	r25, r17
    14c0:	98 f3       	brcs	.-26     	; 0x14a8 <main+0x336>
                                        }
                                }
                                // a command is one char and a value. At
                                // least 3 characters long. It has an '=' on
                                // position 2:
                                if (cmd_pos<2 || cmd_pos>payloadlen-3 || buf[UDP_DATA_P+cmd_pos+1]!='='){
    14c2:	92 30       	cpi	r25, 0x02	; 2
    14c4:	68 f0       	brcs	.+26     	; 0x14e0 <main+0x36e>
    14c6:	e9 2f       	mov	r30, r25
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	81 2f       	mov	r24, r17
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	02 97       	sbiw	r24, 0x02	; 2
    14d0:	e8 17       	cp	r30, r24
    14d2:	f9 07       	cpc	r31, r25
    14d4:	2c f4       	brge	.+10     	; 0x14e0 <main+0x36e>
    14d6:	e7 54       	subi	r30, 0x47	; 71
    14d8:	ff 4f       	sbci	r31, 0xFF	; 255
    14da:	83 a5       	ldd	r24, Z+43	; 0x2b
    14dc:	8d 33       	cpi	r24, 0x3D	; 61
    14de:	21 f0       	breq	.+8      	; 0x14e8 <main+0x376>
                                        strcpy(str,"e=no_cmd");
    14e0:	c6 01       	movw	r24, r12
    14e2:	68 e6       	ldi	r22, 0x68	; 104
    14e4:	70 e0       	ldi	r23, 0x00	; 0
    14e6:	1f c0       	rjmp	.+62     	; 0x1526 <main+0x3b4>
                                        goto ANSWER;
                                }
                                // supported commands are
                                // t=1 t=0 t=?
                                if (buf[UDP_DATA_P+cmd_pos]=='t'){
    14e8:	82 a5       	ldd	r24, Z+42	; 0x2a
    14ea:	84 37       	cpi	r24, 0x74	; 116
    14ec:	a9 f4       	brne	.+42     	; 0x1518 <main+0x3a6>
                                        cmdval=buf[UDP_DATA_P+cmd_pos+2];
    14ee:	e4 a5       	ldd	r30, Z+44	; 0x2c
                                        if(cmdval=='1'){
    14f0:	e1 33       	cpi	r30, 0x31	; 49
    14f2:	11 f4       	brne	.+4      	; 0x14f8 <main+0x386>
                                                PORTC|= (1<<PORTC0);// transistor on
    14f4:	a8 9a       	sbi	0x15, 0	; 21
    14f6:	08 c0       	rjmp	.+16     	; 0x1508 <main+0x396>
                                                strcpy(str,"t=1");
                                                goto ANSWER;
                                        }else if(cmdval=='0'){
    14f8:	e0 33       	cpi	r30, 0x30	; 48
    14fa:	11 f4       	brne	.+4      	; 0x1500 <main+0x38e>
                                                PORTC &= ~(1<<PORTC0);// transistor off
    14fc:	a8 98       	cbi	0x15, 0	; 21
    14fe:	08 c0       	rjmp	.+16     	; 0x1510 <main+0x39e>
                                                strcpy(str,"t=0");
                                                goto ANSWER;
                                        }else if(cmdval=='?'){
    1500:	ef 33       	cpi	r30, 0x3F	; 63
    1502:	51 f4       	brne	.+20     	; 0x1518 <main+0x3a6>
                                                if (PORTC & (1<<PORTC0)){
    1504:	a8 9b       	sbis	0x15, 0	; 21
    1506:	04 c0       	rjmp	.+8      	; 0x1510 <main+0x39e>
                                                        strcpy(str,"t=1");
    1508:	c6 01       	movw	r24, r12
    150a:	61 e7       	ldi	r22, 0x71	; 113
    150c:	70 e0       	ldi	r23, 0x00	; 0
    150e:	0b c0       	rjmp	.+22     	; 0x1526 <main+0x3b4>
                                                        goto ANSWER;
                                                }
                                                strcpy(str,"t=0");
    1510:	c6 01       	movw	r24, r12
    1512:	65 e7       	ldi	r22, 0x75	; 117
    1514:	70 e0       	ldi	r23, 0x00	; 0
    1516:	07 c0       	rjmp	.+14     	; 0x1526 <main+0x3b4>
                                                goto ANSWER;
                                        }
                                }
                                strcpy(str,"e=no_such_cmd");
    1518:	c6 01       	movw	r24, r12
    151a:	69 e7       	ldi	r22, 0x79	; 121
    151c:	70 e0       	ldi	r23, 0x00	; 0
    151e:	03 c0       	rjmp	.+6      	; 0x1526 <main+0x3b4>
                                goto ANSWER;
                        }
                        strcpy(str,"e=invalid_pw");
    1520:	c6 01       	movw	r24, r12
    1522:	67 e8       	ldi	r22, 0x87	; 135
    1524:	70 e0       	ldi	r23, 0x00	; 0
    1526:	0e 94 a5 0a 	call	0x154a	; 0x154a <strcpy>
ANSWER:
                        make_udp_reply_from_request(buf,str,strlen(str),MYUDPPORT);
    152a:	f6 01       	movw	r30, r12
    152c:	01 90       	ld	r0, Z+
    152e:	00 20       	and	r0, r0
    1530:	e9 f7       	brne	.-6      	; 0x152c <main+0x3ba>
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	ec 19       	sub	r30, r12
    1536:	fd 09       	sbc	r31, r13
    1538:	89 eb       	ldi	r24, 0xB9	; 185
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	b6 01       	movw	r22, r12
    153e:	4e 2f       	mov	r20, r30
    1540:	20 eb       	ldi	r18, 0xB0	; 176
    1542:	34 e0       	ldi	r19, 0x04	; 4
    1544:	0e 94 08 06 	call	0xc10	; 0xc10 <make_udp_reply_from_request>
    1548:	a6 ce       	rjmp	.-692    	; 0x1296 <main+0x124>

0000154a <strcpy>:
    154a:	fb 01       	movw	r30, r22
    154c:	dc 01       	movw	r26, r24
    154e:	01 90       	ld	r0, Z+
    1550:	0d 92       	st	X+, r0
    1552:	00 20       	and	r0, r0
    1554:	e1 f7       	brne	.-8      	; 0x154e <strcpy+0x4>
    1556:	08 95       	ret

00001558 <strncmp>:
    1558:	fb 01       	movw	r30, r22
    155a:	dc 01       	movw	r26, r24
    155c:	41 50       	subi	r20, 0x01	; 1
    155e:	50 40       	sbci	r21, 0x00	; 0
    1560:	30 f0       	brcs	.+12     	; 0x156e <strncmp+0x16>
    1562:	8d 91       	ld	r24, X+
    1564:	01 90       	ld	r0, Z+
    1566:	80 19       	sub	r24, r0
    1568:	19 f4       	brne	.+6      	; 0x1570 <strncmp+0x18>
    156a:	00 20       	and	r0, r0
    156c:	b9 f7       	brne	.-18     	; 0x155c <strncmp+0x4>
    156e:	88 1b       	sub	r24, r24
    1570:	99 0b       	sbc	r25, r25
    1572:	08 95       	ret

00001574 <__eerd_word>:
    1574:	df 92       	push	r13
    1576:	ef 92       	push	r14
    1578:	ff 92       	push	r15
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	7b 01       	movw	r14, r22
    1580:	8c 01       	movw	r16, r24
    1582:	fb 01       	movw	r30, r22
    1584:	09 95       	icall
    1586:	d8 2e       	mov	r13, r24
    1588:	c8 01       	movw	r24, r16
    158a:	01 96       	adiw	r24, 0x01	; 1
    158c:	f7 01       	movw	r30, r14
    158e:	09 95       	icall
    1590:	98 2f       	mov	r25, r24
    1592:	8d 2d       	mov	r24, r13
    1594:	1f 91       	pop	r17
    1596:	0f 91       	pop	r16
    1598:	ff 90       	pop	r15
    159a:	ef 90       	pop	r14
    159c:	df 90       	pop	r13
    159e:	08 95       	ret

000015a0 <__eewr_word>:
    15a0:	df 92       	push	r13
    15a2:	ef 92       	push	r14
    15a4:	ff 92       	push	r15
    15a6:	0f 93       	push	r16
    15a8:	1f 93       	push	r17
    15aa:	d7 2e       	mov	r13, r23
    15ac:	7a 01       	movw	r14, r20
    15ae:	8c 01       	movw	r16, r24
    15b0:	fa 01       	movw	r30, r20
    15b2:	09 95       	icall
    15b4:	c8 01       	movw	r24, r16
    15b6:	01 96       	adiw	r24, 0x01	; 1
    15b8:	6d 2d       	mov	r22, r13
    15ba:	f7 01       	movw	r30, r14
    15bc:	09 95       	icall
    15be:	1f 91       	pop	r17
    15c0:	0f 91       	pop	r16
    15c2:	ff 90       	pop	r15
    15c4:	ef 90       	pop	r14
    15c6:	df 90       	pop	r13
    15c8:	08 95       	ret

000015ca <itoa>:
    15ca:	fb 01       	movw	r30, r22
    15cc:	9f 01       	movw	r18, r30
    15ce:	e8 94       	clt
    15d0:	42 30       	cpi	r20, 0x02	; 2
    15d2:	c4 f0       	brlt	.+48     	; 0x1604 <itoa+0x3a>
    15d4:	45 32       	cpi	r20, 0x25	; 37
    15d6:	b4 f4       	brge	.+44     	; 0x1604 <itoa+0x3a>
    15d8:	4a 30       	cpi	r20, 0x0A	; 10
    15da:	29 f4       	brne	.+10     	; 0x15e6 <itoa+0x1c>
    15dc:	97 fb       	bst	r25, 7
    15de:	1e f4       	brtc	.+6      	; 0x15e6 <itoa+0x1c>
    15e0:	90 95       	com	r25
    15e2:	81 95       	neg	r24
    15e4:	9f 4f       	sbci	r25, 0xFF	; 255
    15e6:	64 2f       	mov	r22, r20
    15e8:	77 27       	eor	r23, r23
    15ea:	0e 94 16 0b 	call	0x162c	; 0x162c <__udivmodhi4>
    15ee:	80 5d       	subi	r24, 0xD0	; 208
    15f0:	8a 33       	cpi	r24, 0x3A	; 58
    15f2:	0c f0       	brlt	.+2      	; 0x15f6 <itoa+0x2c>
    15f4:	89 5d       	subi	r24, 0xD9	; 217
    15f6:	81 93       	st	Z+, r24
    15f8:	cb 01       	movw	r24, r22
    15fa:	00 97       	sbiw	r24, 0x00	; 0
    15fc:	a1 f7       	brne	.-24     	; 0x15e6 <itoa+0x1c>
    15fe:	16 f4       	brtc	.+4      	; 0x1604 <itoa+0x3a>
    1600:	5d e2       	ldi	r21, 0x2D	; 45
    1602:	51 93       	st	Z+, r21
    1604:	10 82       	st	Z, r1
    1606:	c9 01       	movw	r24, r18
    1608:	0c 94 06 0b 	jmp	0x160c	; 0x160c <strrev>

0000160c <strrev>:
    160c:	dc 01       	movw	r26, r24
    160e:	fc 01       	movw	r30, r24
    1610:	67 2f       	mov	r22, r23
    1612:	71 91       	ld	r23, Z+
    1614:	77 23       	and	r23, r23
    1616:	e1 f7       	brne	.-8      	; 0x1610 <strrev+0x4>
    1618:	32 97       	sbiw	r30, 0x02	; 2
    161a:	04 c0       	rjmp	.+8      	; 0x1624 <strrev+0x18>
    161c:	7c 91       	ld	r23, X
    161e:	6d 93       	st	X+, r22
    1620:	70 83       	st	Z, r23
    1622:	62 91       	ld	r22, -Z
    1624:	ae 17       	cp	r26, r30
    1626:	bf 07       	cpc	r27, r31
    1628:	c8 f3       	brcs	.-14     	; 0x161c <strrev+0x10>
    162a:	08 95       	ret

0000162c <__udivmodhi4>:
    162c:	aa 1b       	sub	r26, r26
    162e:	bb 1b       	sub	r27, r27
    1630:	51 e1       	ldi	r21, 0x11	; 17
    1632:	07 c0       	rjmp	.+14     	; 0x1642 <__udivmodhi4_ep>

00001634 <__udivmodhi4_loop>:
    1634:	aa 1f       	adc	r26, r26
    1636:	bb 1f       	adc	r27, r27
    1638:	a6 17       	cp	r26, r22
    163a:	b7 07       	cpc	r27, r23
    163c:	10 f0       	brcs	.+4      	; 0x1642 <__udivmodhi4_ep>
    163e:	a6 1b       	sub	r26, r22
    1640:	b7 0b       	sbc	r27, r23

00001642 <__udivmodhi4_ep>:
    1642:	88 1f       	adc	r24, r24
    1644:	99 1f       	adc	r25, r25
    1646:	5a 95       	dec	r21
    1648:	a9 f7       	brne	.-22     	; 0x1634 <__udivmodhi4_loop>
    164a:	80 95       	com	r24
    164c:	90 95       	com	r25
    164e:	bc 01       	movw	r22, r24
    1650:	cd 01       	movw	r24, r26
    1652:	08 95       	ret

00001654 <_exit>:
    1654:	f8 94       	cli

00001656 <__stop_program>:
    1656:	ff cf       	rjmp	.-2      	; 0x1656 <__stop_program>
